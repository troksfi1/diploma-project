\chapter{Testování} \label{testsSection}
%Tato kapitola se bude věnovat především UI testování a to z~několika různých pohledů. 

%\section{Typy UI testů}

Mezi základní dva druhy testování UI patří manuální a automatizované testování \cite{testing}. Za účelem otestování frameworku Compose Multiplatform
se tato kapitola věnuje především UI testům, které tento framework přímo podporuje, a těmi jsou právě automatizované UI testy \cite{testingUI}.
Ty je dále možné rozdělit na takzvané \textit{Unit} testy neboli testy jednotlivých UI komponent a takzvané \textit{End-to-End} testy, 
které simulují reálný průchod aplikací - například uživatelem. Před samotnou ukázkou způsobu implementace těchto testů, se tato kapitola
věnuje samotným konceptům, na kterých jsou oba tyto typy testování postaveny a ukázce testovacích případů, které byly k implementaci
těchto testů použity.

% \section{Uživatelské rozhraní}
% UI testy se používají k~ověření, že uživatelské rozhraní aplikace funguje podle očekávání. To zahrnuje testování prvků uživatelského rozhraní, 
% uživatelských interakcí a navigačních toků, aby se zajistilo plynulé uživatelské prostředí.

% Mezi základní typy UI testy se řadí UI testy testující kritické uživatelské interakce na jedné obrazovce a dále například navigační testy testující
% správnost fungování navigace v~dané aplikaci.


% \section{Výkon aplikace}

% \section{Přístupnost aplikace}
% Mimi UI testů byla aplikace manuálně testovaná
% K~testování přístupnosti byla použita funkce TalkBack, která pomáhá nevidomým a slabozrakým ovládat zařízení Android pomocí hmatové a 
% hlasové odezvy. 


% \section{Kompatibilita}
% Testování aplikace na různých zařízeních s~různými velikostmi obrazovek, rozlišeními a hardwarovými konfiguracemi, aby se zajistilo, že funguje 
% správně na široké škále zařízení.


\section{Možnosti testování UI v~Compose Multiplatform}
Od verze 1.6.0 Compose Multiplatform umožňuje testování UI na všech podporovaných platformách. \cite{composeNews1.6.0}
Testování aplikací založených na frameworku Compose Multiplatform je stejně jako tvorba samotného UI založeno na Jetpack Compose, a využívá 
proto i stejných konceptů. 

\medskip

Mezi tyto klíčové koncepty testovaní UI se řadí následující:


\subsection*{Sémantika}
Jak již bylo zmíněno několikrát, tak uživatelské rozhraní frameworku Compose Multiplatform je založeno na stromové struktuře elementů, a z toho důvodu 
i samotné UI testy používají tuto strukturu k interakci s jednotlivými prvky této hierarchie. K rozlišení uzlů sémantického
stromu se používají buďto popisy těchto elementů jako je například název tlačítka nebo lze taktéž využít popisků
sloužících k přístupnosti (v kódu označovaných pomocí štítků \code{contentDescription}) \cite{testingUISeman}.


\subsection*{Testování rozhraní}
K samotnému testovaní UI elementů se používají tři hlavní principy, které se
označují jako \textit{Finders}, \textit{Actions} a  \textit{Assertions} \cite{testingUIApis}.

V první fázi testovaní je nejprve potřeba samotné testované elementy vyhledat. K tomu slouží právě \textit{Finders}, které  umožňují najít
 uzel nebo uzly ve stromové UI struktuře pomocí odpovídajícího sémantického stromu. Případně je dané elementy možné najít
pomocí takzvaných \textit{Matchers}, které umožňují najít hledané UI komponenty například podle aktuálního stavu 
(funkce \code{isEnabled()}, \code{hasProgressBarRangeInfo()} a další).

Po nalezení potřebných komponent je možné přistoupit například k takzvaným \textit{Actions}, prostřednictvím kterých je možné vykonávat akce podobné
těm, které vykonávají uživatelé (funkce \code{performClick(), performScrollTo()} a další).

Pro kontrolu správnosti provedení těchto akcí se používají takzvaná tvrzení (\textit{Assertions}), které ověří zdali vybrané UI prvky
mají požadované atributy. \cite{testingUIApis}

\begin{sloppypar}
\subsection*{Synchronizace}
Dnešní asynchronní povaha mobilních aplikací a frameworků často ztěžuje psaní spolehlivých a opakovatelných testů. Testovací rámce
musí v případě asynchronních operací čekat, než na ni aplikace zareaguje a až následně vykonávat příslušné testovací operace. 
Tyto reakce testovacích rámců, jsou v případě moderních testovacích rámců jako je Compose, již běžná a automatická věc \cite{testingUISynchro}. Přesto jsou zde ale
situace, při kterých je synchronizaci testů s uživatelským rozhraním potřeba explicitně řídit.

Takovým příkladem může být například situace, kdy aplikace čeká na odpověď webového serveru. V takové situaci je v rámci testů možné 
definovat funkce jako například \code{waitUntilNodeCount(matcher, count, timeoutMs)}, které pozdrží testovaní do doby, než bude aplikace
připravena s pokračovaním testů.
\end{sloppypar}

%\myparagraph{Testování interoperability}

\section{Testovací případy}\label{testCases}
Testovací případ (zkráceně TC - z~anglického \uv{test case}) je sada kroků nebo akcí, které jsou prováděny při testování softwarových produktů. 
Cílem zadefinování testovacích případů je ověřit, zda se testovaná aplikace chová podle očekávání a splňuje předem definované požadavky. 

\bigskip

Každý testovací případ obvykle obsahuje následující prvky:

\begin{itemize}
  \item \textbf{Popis:} Stručný popis toho, co daný testovací případ testuje. % a jaké jsou očekávané výsledky.
  %\item \textbf{Předpoklady:} Podmínky, které musí být splněny nebo konfigurace, která musí být provedena před spuštěním testu.
  \item \textbf{Kroky:} Konkrétní kroky, které musí být k~provedení testu provedeny.
  \item \textbf{Očekávané výsledky:} Popis očekávaných výsledků testu po dokončení kroků.
  %\item \textbf{Aktuální výsledky:} Skutečné výsledky testu, které jsou porovnány s~očekávanými výsledky k~určení úspěšnosti testu.
\end{itemize}

\medskip

Na základě této struktury byly sepsány následující testovací případy:


\myparagraph{TC1: Zobrazení aktuálních novinek}
Zobrazení aktuálních novinek a jejich detailu.

\begin{enumerate}
  \item \textbf{Kroky:}
    \begin{enumerate}
      \item Navigace na stránku zobrazující aktuální novinky.
      \item Ověření, že systém zobrazil seznam aktuálních novinek.
      \item Kliknutí na konkrétní novinku.
      \item Ověření, že systém zobrazil detaily vybrané novinky.
    \end{enumerate}
  \item \textbf{Očekávaný výstup:}
    \begin{itemize}
      \item Seznam aktuálních novinek byl zobrazen.
      \item Po kliknutí na konkrétní novinku byl zobrazen její detail.
    \end{itemize}
\end{enumerate}

\myparagraph{TC2: Odkázání na zaplacení parkovacích poplatků}
Zobrazení parkovacích zón a následné vybrání parkovací zóny s odkazem na zaplacení parkovacího poplatku.

\begin{enumerate}
  \item \textbf{Kroky:}
    \begin{enumerate}
      \item Navigace na stránku zobrazující parkovací zóny.
      \item Kliknutí do vyhledávacího pole.
      \item Zvolení požadované parkovací zóny.
      \item Ověření, že systém zobrazil vybranou parkovací zónu.
      \item Kliknutí na tlačítko \uv{zaplatit}.
      \item Ověření, že systém uživatele přesměroval na platební portál města.
    \end{enumerate}
  \item \textbf{Očekávaný výstup:}
    \begin{itemize}
      \item Seznam parkovacích zón byl zobrazen.
      \item Dialogový panel byl zobrazen.
      \item Uživatel byl přesměrován na platební portál města.
    \end{itemize}
\end{enumerate}

\myparagraph{TC3: Kontrola stavu po zrušení akce výběru datového rozsahu}
Zobrazení dialogového okna pro výběr datového rozsahu a následné zrušení prováděné akce.

\begin{enumerate}
  \item \textbf{Kroky:}
    \begin{enumerate}
      \item Navigace na stránku zobrazující události.
      \item Ověření, že systém zobrazil filtrační možnosti.
      \item Zvolení tlačítka pro výběr datového rozsahu.
      \item Ověření, že systém zobrazil patřičné dialogové okno. 
      \item Zvolení tlačítka zrušit pro zrušení akce výběru datového rozsahu.
      \item Ověření stavu filtračních možností.
    \end{enumerate}
  \item \textbf{Očekávaný výstup:}
    \begin{itemize}
      \item Systém zobrazí dialogové okno pro výběr datového rozsahu.
      \item Filtrační možnosti zůstanou ve stejném stavu jako před provedou akcí.
    \end{itemize}
\end{enumerate}

\section{Implementace testů}
% %Jelikož je testovobvní pos
% Před tím něž bylo možné UI testy implementovat bylo potřebné jejich použití př

% \begin{listing}[H]
%   \caption{Integrace UI testů pomocí Gradle}\label{lst:testsIntegration}
%   \begin{minted}{kotlin}
% sourceSets {
%   val desktopTest by getting
%   // Adds common test dependencies
%   commonTest.dependencies {
%     implementation(kotlin("test"))
%       @OptIn(org.jetbrains.compose.ExperimentalComposeLibrary::class)
%       implementation(compose.uiTest)
%   }
%   // Adds the desktop test dependency
%   desktopTest.dependencies {
%       implementation(compose.desktop.currentOs)
%   }
% }

% \end{minted}
% \end{listing}


\subsection{Testy jednotlivých UI komponent}
Před tím, než bylo přistoupeno k testování UI dle výše zmíněných scénářů, bylo nejprve implementováno několik testů pro ověření správné 
funkcionality a vzhledu jednotlivých komponent jako jsou tlačítka, textová pole, seznamy, obrázky atd.

Účelem těchto testů je zajistit, že každá komponenta aplikace funguje správně a že se zobrazuje v souladu s návrhem a specifikacemi. 
To zahrnuje ověření interakcí s komponentou jako je klikání, vyplňování políček, posouvání seznamů atd., stejně jako ověření vzhledu komponenty v 
různých situacích jako je například změna orientace zařízení.

\bigskip

Pro ukázku metod používaných pro ověření správnosti zobrazení jednotlivých UI komponent slouží následující ukázka kódu \ref{lst:testImplementation}.

\begin{listing}[H]
  \caption{Metody pro testování UI komponent}\label{lst:testImplementation}
  \begin{minted}{kotlin}
@OptIn(ExperimentalTestApi::class)
@Test
fun check_properties_and_return() = runComposeUiTest {
  ...
  //Ověří, že daná komponenta byla nalezena a je součástí stromu UI komponent.
  onNodeWithText("Závady").assertExists()
  //Ověří, že je daný uzel sémantického stromu zobrazen na obrazovce.
  onNodeWithText("Závady").assertIsDisplayed()
  //Ověří, že rozvržení daného uzle má výšku větší než 100 dp
  onNodeWithText("Závady").assertHeightIsAtLeast(100.dp)
}
\end{minted}
\end{listing}

\subsection{End-to-end testy}
End-to-end (E2E) testy jsou typem testování, který simuluje reálné uživatelské scénáře a ověřuje fungování celé aplikace z pohledu uživatele \cite{testingE2E}.
Tyto testy prověřují integraci jednotlivých komponent aplikace a zajišťují, že aplikace pracuje korektně a očekávaným způsobem od začátku až 
do konce vykonávaného procesu.

Při E2E testování je často využíván emulátor nebo reálné zařízení, aby se testování co nejvíce blížilo reálným uživatelským podmínkám. 
%Testy mohou obsahovat různé scénáře, jako je například registrace uživatele, přihlášení, provádění akcí v aplikaci a ověřování výsledků.

Cílem E2E testů je zajistit, že aplikace funguje spolehlivě a správně napříč všemi vrstvami a komponentami a že uživatelé mohou dosáhnout 
svých cílů bez problémů.

\bigskip
Při implementaci těchto testů bylo postupováno na základě testovacích scénářů uvedených v sekci \textit{Testovací případy \ref{testCases}} a pro
ukázku implementace byl zvolen E2E test odpovídající třetímu testovacímu případu (viz výpis kódu  \ref{lst:E2ETest}). 

\begin{listing}[H]
  \caption{Implementace E2E testu podle TC3}\label{lst:E2ETest}
  \begin{minted}{kotlin}
    fun nav_to_events_open_calendar_press_cancel_check_buttons_state() {

        val dbDriverFactoryModule = module {
            single { DatabaseDriverFactory(instrumentationContext) }
        }
        loadKoinModules(dbDriverFactoryModule)

        rule.setContent { App() }

        rule.onNodeWithText("Události").performClick()
        rule.onNodeWithText("Dnes").assertIsSelected()

        rule.onNodeWithContentDescription("calendar icon").performClick()
        rule.onNodeWithText("Zrušit").performClick()

        rule.onNodeWithText("Dnes").assertIsSelected()
        rule.onNodeWithText("Zítra").assertIsNotSelected()
        rule.onNodeWithContentDescription("calendar icon").assertIsNotSelected()
    }
\end{minted}
\end{listing}


% android already in production with hell a lot of features now If you want to share code among these and have single code base, 
% going with flutter is bad idea .. Since its take nativity out. So hence you want both the teams to have a common business logic 
% and networking thing then KMM is the way to go 
