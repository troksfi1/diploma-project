\chapter{Implementace}


\section{Založení Compose Multiplatform projektu}
K~založení projektu byl použit nástroj \textit{Kotlin Multiplatform Wizard} od společnosti JetBrains, který slouží k~rychlému vytvoření projektu
založeném na technologiích KMP. Tento nástroj se taktéž stará o~vytvoření sestavovacího skriptu založeného na technologii Gradle, který je následně možné 
použít k~sestavení multiplatformních aplikací založených na KMP a frameworku Compose Multiplatform.
 
 
 %se používá nástroj zvaný Gradle.

%se stejně jako v případě vývoje Android aplikací stará   

%Ten se stará o založení sestavovací skriptu založeném na technologii Gradle a dále se stará o vytvoření příslušných balíčků na základě vybraných platforem.

%

\subsection{Gradle} \label{gradleChapter}
Gradle je open-source nástroj pro automatizaci sestavení a správu závislostí při vývoji softwaru. \cite{gradle}
%Je podobný technologiím Ant nebo Maven, které byly vyvinuty pro zjednodušení procesu sestavení a nasazení softwaru.
Gradle používá deklarativní doménově specifické jazyky (DSL), díky kterým je možné definovat sestavení a konfiguraci projektu pomocí srozumitelné
a flexibilní syntaxe. Od verze 3.0 z~roku 2016 je možné psát Gradle skripty v~jazyce Kotlin DSL a od roku 2023 je Kotlin DSL primárním jazykem 
pro jejich zápis \cite{gradleKot}. To umožňuje vývojářům snadno konfigurovat sestavení a spravovat závislosti na knihovnách a modulech v~jazyku se stejnou
syntaxí jako je ta, používaná pro ostatní části projektu. 

%Kotlin DSL tak nahazuje dříve používaný Groovy DSL, který byl používaný kvůli 

%K vytvoření projektu založeném na Compose Multiplatform je doporučeno využití právě totoho sestavovacího nástoroje. 

K~tomu, aby bylo možné Compose Multiplatform v~projektu použít, je zapotřebí do projektového souboru \code{build.gradle.kts} přidat Compose 
Multiplatform plugin (viz výpis kódu \ref{lst:ComposePlugin}).

\begin{listing}[H]
\caption{Integrace Compose Multiplatform zásuvného modulu do sestavovacího scriptu}\label{lst:ComposePlugin}
\begin{minted}{kotlin}
    plugins {
      id("org.jetbrains.compose") version "1.6.0"
    }
\end{minted}
\end{listing}

Dále je zapotřebí vybrat platformy, pro které má být aplikace sestavována a podle nich vytvořit příslušné balíčky (viz sekce \textit{Kotlin Multiplatform \ref{projectStructure}}).
V~případě implementované aplikace se jedná o~platformy \textit{Android}, \textit{iOS} a \textit{desktop}, které bylo nutné specifikovat v~projektovém 
souboru \code{build.gradle.kts} (viz řádky 2 - 21 na výpisu kódu \ref{lst:LibIntegration}).
Podle těchto platforem lze následně v~příslušném \code{build.gradle.kts} vytvořit takzvané \textit{sourceSets}, díky kterým je možné
pro každou platformu implementovat platformě specifické závislosti. Tyto závislosti se následně vkládají do příslušných
\textit{sourceSets} podle toho, zdali se jedná o~multiplatformní (\code{commonMain}) nebo nativní závislost (\code{androidMain}, \code{iosMain}, atd.).

Pro ukázku, jak taková multiplatformní závislost může vypadat, slouží řádky 23 - 28 na ukázce kódu \ref{lst:LibIntegration}, pomocí 
kterých je do projektu přidána knihovna umožnující implementaci multiplatformní navigace.

\begin{listing}[H]
\caption{Lib integration}\label{lst:LibIntegration}
\begin{minted}[xleftmargin=\parindent,linenos]{kotlin}
  kotlin {
    androidTarget {
        compilations.all {
            kotlinOptions {
                jvmTarget = "11"
            }
        }
    }

    jvm("desktop")

    listOf(
        iosX64(),
        iosArm64(),
        iosSimulatorArm64()
    ).forEach { iosTarget ->
        iosTarget.binaries.framework {
            baseName = "ComposeApp"
            isStatic = true
        }
    }

    sourceSets {
      commonMain.dependencies {
        implementation(libs.voyager.navigator)
        ...
      }
    }
  }  
\end{minted}
\end{listing}

Dále je potřeba do spouštěcích souborů každé platformy integrovat multiplatformní část aplikace. Ta může být do nativního kódu přidána
například pomocí \textit{Composable} funkce, která je součástí společné části aplikace.
Ve výpisu kódu \ref{lst:SharedIntegration} je to funkce \code{App()}, která je volána z~nativního Android kódu a stará se
o~deklaraci veškerého multiplatformního UI.
\begin{listing}[H]
  \caption{Integrace sdílené aplikace do hlavní Android \textit{Activity}}\label{lst:SharedIntegration}
  \begin{minted}{Kotlin}
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            App()
        }
    }
}
\end{minted}
\end{listing}


%Stejným způsobem je potřeba integrovat tuto funkci i do ostatních spouštěcích souborů



%Jelikož časem projekt obsahuje je vhodné pro správu verzí použít takzvaný version katalog. 

\myparagraph{Gradle version catalog}
Gradle version catalog je obyčejný soubor ve formátu TOML, který umožňuje snadněji přidávat a spravovat závislosti v rámci celého projektu. 
Místo ručního přidávání závislostí a pluginů do každého modulu zvlášť, je možné shromáždit veškeré závislosti v~tomto souboru a zadefinovat rovněž
verzi, která má být pro tento modul použita napříč celým projektem. \cite{versionCatalog}

Příklad toho, jak mohou být dříve zmíněné závislosti přepsány do version
katalogu, je uveden ve výpisu kódu \ref{lst:VersionCalalog}.

\begin{listing}[H]
\caption{Version katalog}\label{lst:VersionCalalog}
\begin{minted}{toml}
[versions]
compose-plugin = "1.6.0"
voyagerVersion = "1.0.0"
    
[libraries]
voyager-navigator = { module = "cafe.adriel.voyager:voyager-navigator", 
                      version.ref = "voyagerVersion" }
[plugins]
jetbrainsCompose = { id = "org.jetbrains.compose",
                     version.ref = "compose-plugin" }
\end{minted}
\end{listing}

%\section{Navigace a lokalizace v implementaci}


\section{Design systém} \label{designSystemImpl}
Při implementaci design systému pomocí Compose Multiplatform byla snaha, co nejpřesněji napodobit navržený design systém ze sekce 
\textit{Design system \ref{designSystemSection}}
tak, aby byl uživateli navozen maximální pocit jednoty s~dosavadními informačními systémy města.

Od verze 1.6 Compose Multiplatform umožňuje přístup ke zdrojům ve společném kódu na všech podporovaných platformách, což výrazně usnadňuje 
implementaci navrženého design systému. 

%a implementaci design systému a umožňuje sdílet barvy, písma napříč platformami. 

\subsection*{Barvy} \label{colorSection}
Základní barvy pro světlý motiv byly zvoleny na základě navrženého design systému
%který byl navržen na základě vizuálního stylu města, které město Příbram využívá při všech prezentačních příležitostech.
a zbylé barvy jako například barvy pro výplň pozadí nebo pro tmavý režim byly dopočítány ze základních barev nástrojem \textit{Material Theme Builder}.
%Ten barvy rovnou dopočítá tak, aby 

Pro použití vybraných barev v~aplikaci bylo zapotřebí jednotlivé barvy nejprve zadefinovat následujícím způsobem:

\begin{listing}[H]
\caption{Zadefinování barev}\label{lst:Colors}
\begin{minted}{Kotlin}
val md_theme_light_primary = Color(0xFFBC004C)
val md_theme_light_onPrimary = Color(0xFFFFFFFF)
val md_theme_light_primaryContainer = Color(0xFFFFD9DE)
val md_theme_light_onPrimaryContainer = Color(0xFF400015)
...
val md_theme_dark_primary = Color(0xFFFFB2BE)
val md_theme_dark_onPrimary = Color(0xFF660026)
...
\end{minted}
\end{listing}

Takto zadefinované barvy je následně možné použít napříč aplikací k~obarvení tlačítek, textů, ploch a dalších UI komponent.

Mimo jiné jsou barvy taktéž použity pro definování barevných motivů, které se definují následujícím způsobem:
\begin{listing}[H]
\caption{Definice barevných motivů}\label{lst:ThemeDef}
\begin{minted}{Kotlin}
private val LightColors = lightColorScheme(
  primary = md_theme_light_primary,
  onPrimary = md_theme_light_onPrimary,
  primaryContainer = md_theme_light_primaryContainer,
  onPrimaryContainer = md_theme_light_onPrimaryContainer,
  ...
)
private val DarkColors = darkColorScheme(
  primary = md_theme_dark_primary,
  onPrimary = md_theme_dark_onPrimary,
  primaryContainer = md_theme_dark_primaryContainer,
  ...
)
\end{minted}
\end{listing}

Díky takto zadefinovaným motivům je následně možné obarvit veškeré komponenty aplikace podle aktuálně používaného režimu.

V~aplikaci byla proto implementována \textit{Composable} funkce AppTheme (viz výpis kódu \ref{lst:colorsDef}), která je z~pohledu stromové struktury
UI předkem veškerých vykreslovaných UI komponent. Díky této implementaci je tak možné měnit barevné režimy i za běhu aplikace. 
\begin{listing}[H]
\caption{Aplikace barevných motivů}\label{lst:colorsDef}
\begin{minted}{Kotlin}
  @Composable
  fun AppTheme(
    useDarkTheme: Boolean = isSystemInDarkTheme(),
    content: @Composable() () -> Unit
  ) {
    val colors = if (!useDarkTheme) {
      LightColors
    } else {
      DarkColors
    }
  
    MaterialTheme(
      colorScheme = colors,
      content = content
    )
  }
\end{minted}
\end{listing}


\subsection*{Typografie}
Vybraný Material Design definuje celkem 15 stylů písma, kde každé z~nich má předem určený způsob použití. \cite{material3} 
Jelikož se jedná o~styly písma přímo zvolené systémem Material Design, tak lze k~těmto stylům přistupovat přes
\textit{Composable} funkci \code{MaterialTheme} z~balíčku \code{androidx.compose.material3} popsanou ve výpisu~kódu \ref{lst:colorsDef}.
Na tomto příkladě je vidět implementace jednoho stylu písma - konkrétně \textit{headlineMedium}, který je odvozen ze základních stylů písma 
definovaných v~rámci sekce \textit{Design system \ref{designSystemSection}}.

\begin{listing}[H]
\caption{Ukázka použití stylu písma}\label{lst:typographyExample}
\begin{minted}{Kotlin}
Text(
  text = news.title,
  style = MaterialTheme.typography.headlineMedium
)
\end{minted}
\end{listing}

\section{Tvorba UI obrazovek}
Jak již bylo zmíněno v~kapitole \textit{Architektura frameworku Compose Multiplatform \ref{ComposeArch}}, tak k~tvorbě UI se v~Compose Multiplatform 
používají takzvané \textit{Composable} funkce, které představují jednotlivé UI prvky zobrazované na obrazovce koncového zařízení. 

Tyto \textit{Composable} funkce, které přestavují stavební bloky celého UI mohou sloužit k~reprezentaci jednotlivých tlačítek (\code{Button()}), 
textů (\code{Text()}) obrázků \code{Image()}, ale také celých souborů těchto prvků jako jsou například celé obrazovky.

Mimo těchto funkcí je UI možné tvořit ještě pomocí takzvaných Layout funkcí, mezi které se řadí například \code{Column}, která vnořené \textit{Composable}
funkce uspořádává do sloupce nebo \code{Row}, která vnořené elementy řadí naopak do řádku.

Jelikož se tato sekce věnuje právě tvorbě UI jednotlivých obrazovek, na následujícím výpisu kódu \ref{lst:ConsumeUIState} je ukázáno, jak mohou
 být do sebe dříve zmíněné Composable funkce zanořeny, čímž tvoří takzvaný sémantický strom, taktéž popsaný v~kapitole 
 \textit{Architektura frameworku Compose Multiplatform \ref{ComposeArch}}

\begin{listing}[H]
\caption{Příklad tvorby UI pomocí frameworku Compose Multiplatform}\label{lst:ConsumeUIState}
\begin{minted}{Kotlin}
  @Composable
  fun HomeScreen {
    // Přidá vnitřní okraj kolem celé zprávy
    Row(modifier = Modifier.padding(all = 8.dp)) {
        Image(
            painter = painterResource(DrawableResource("profile_picture.jpg")),
            contentDescription = "Contact profile picture",
            modifier = Modifier
                // Nastaví velikost obrázku na 40 dp
                .size(40.dp)
                // Ořízne obrázek do kruhu
                .clip(CircleShape)
        )

        // Přidá horizontální mezeru mezi obrázek a sloupec
        Spacer(modifier = Modifier.width(8.dp))

        Column {
            Text(text = msg.author)
            // Přidá vertikální mezeru bezi texty
            Spacer(modifier = Modifier.height(4.dp))
            Text(text = msg.body)
        }
    }
  }
\end{minted}
\end{listing}

%Zároveň 

%Z těchto Composable funkcí se skládá celé UI

Obsahem následujících sekcí je ukázka UI komponent, které byly použity k~implementaci navrženého UI a celkově dává náhled na to,
jak je deklarativní UI pomocí Compose Multiplatform tvořeno. K~tvorbě celého uživatelského rozhraní bylo nejprve přistupováno na základě vytvořených 
drátěných modelů (viz kapitola \textit{Tvorba drátových modelů \ref{navrhWireframes}}) a následně bylo pomocí implementovaného design systému
stylizováno tak, aby odpovídalo navržené podobě UI z~kapitoly \textit{Mockup modely \ref{navrhMockupModelu}}

\subsection{Domovská obrazovka}
Uživatelské rozhraní domovské obrazovky je kompletně implementováno pomocí frameworku Compose Multiplatform. Ani při jeho implementaci nebzlo potřeba
přistoupit k~nativnímu řešení a to ani v případě platformy iOS nebo desktop.

K~implementaci posuvného řádku, který slouží pro zobrazení událostí byla použita vlastní \textit{Composable} komponenta zvaná \code{EventLazyRow} 
(viz výpis kódu \ref{lst:EventLazyRowImpl}),
která je založená na základní UI komponentě zvané \code{LazyRow}. Tato komponenta se obvykle používá v~případech, že je na obrazovku potřeba efektivně 
vykreslit velkého množství položek (kolekce položek), čož je přesně případ vykreslení událostí. Komponenta \code{LazyRow} totiž vykresluje pouze ty položky,
které jsou aktuálně viditelné, čímž nezpomaluje načítání obsahu. V~případě většího množství událostí pracuje na podobném principu a výrazně tak šetří zdroje potřebné k~vykreslení.

\begin{listing}[H]
\caption{Implementace posuvného řádku pomocí \code{LazyRow}}\label{lst:EventLazyRowImpl}
\begin{minted}{Kotlin}
@Composable
fun EventLazyRow(category: EventCategory, state: EventsState) {
    val scrollState = rememberLazyListState()

    Column {
      Text( ... )
      LazyRow(
          state = scrollState,
      ) {
          ...
          items(eventList) { event ->
              EventItem(event = event, onItemClick = {
                  navigator.push(EventDetailScreen(event))
              })
          }
      }
    }
}  
\end{minted}
\end{listing}

Na stejném principu jako \code{LazyRow}, funguje i komponenta \code{LazyColumn}, která naopak posloužila pro vykreslení seznamu novinek.

Dále byla na této obrazovce implementována vlastní tlačítka zvaná \code{ImageButton()}, která například plní funkci přesměrovaní uživatele na 
příslušné informační kanaly města.  

%I~implementaci 

%LAZY ROW LAZY COLLUMN , OBRAZKY POMOCI COIL, STYLOVANI POMOCI DESIGN SYTEMU, VYUZITI DATABAZE, ukazka Event lazy row komponenty

\subsection{Obrazovka \textit{Události}}

V~rámci obrazovky \textit{Události} je používána stejná komponenta pro zobrazování událostí, která již byla aplikována na domovské obrazovce. 

%pro zobrazené událostí "EventLazyRow". 

Každý z~nich obsahuje události z~jedné kategorie. Ty jsou předem připraveny ViewModelem, který při zavolaní nějaké z~filtrovacích
událostí nejprve vybere události, které spadají do vymezeného časového intervalu a následně u~nich zjistí, do jakých kategorií tyto
události patří. Pro každou z těchto kategorii poté vytvoří jeden LazyRow, do kterého umístí příslušné události.

% napsat to bez pohledu uzivatele
Uživatel může filtrovat události buďto podle předem zvolených časových rozmezí jako je \textit{Dnes}, \textit{Zítra} nebo může zvolit vlastní 
rozmezí pomocí kliknutí na ikonu kalendáře. Po kliknutí na ikonu kalendáře se uživateli zobrazí takzvaný \textit{DatePicker}, který umožňuje zvolit požadované časového rozmezí.

K~volbě časových rozmezí \textit{Dnes} a \textit{Zítra} byly zvoleny takzvané \textit{Chips}, konkrétně \code{FilterChips}, které jsou 
navrženy k~filtrování a uživatelé jsou na jejich použití zvyklí i z~jiných aplikací, které používají Material Design.

Celá obrazovka je vzhledem k~nepředvídatelnosti množství zobrazovaných událostí implementována jako rolovací seznam, který se v případě potřeby
rozšíří a umožní tak zobrazit veškeré události pro vybrané datové rozmezí.

\subsection{Obrazovka \textit{Parkování}} \label{parkingScreenImpl}
Hlavní UI komponentou navrženou pro obrazovku \textit{Parkování} je komponenta sloužící k~zobrazení mapových podkladů, která by zároveň umožňovala 
vykreslení překryvné vrstvy reprezentující rozmístění parkovacích zón. Taková knihovna, ale doposud nebyla pro použití na všech požadovaných 
platformách dostupná, a proto bylo zapotřebí použít nativní způsob implementace. 

\subsubsection*{Implementace mapových podkladů}
Mapové podklady byly implementovány pouze pro platformu Android, pro kterou existuje nativní knihovna \textit{Maps Compose} od společnosti Google, 
která poskytuje Jetpack Compose komponenty pro práci s~\text{(Google) Maps SDK}.

K~integraci mapových podkladů do aplikace bylo využito UI komponenty \code{GoogleMap} (viz výpis kódu \ref{lst:GoogleMapview}) z balíčku 
\code{com.google.maps.android.compose}, která umožňuje vložení mapových podkladů na platformě Android. K propojení této nativní části 
se zbytkem aplikace byla použita expect/actual deklarace.

%Před tím něž bylo možné Google Maps v aplici použít bylo nutné 

%\myparagraph{Výběr mapových podkladů}
%získání API je pro by mohli být učovány poplatky a z toho důvodu není přiloženo v kódu.  
\begin{listing}[H]
\caption{GoogleMap element}\label{lst:GoogleMapview}
\begin{minted}{Kotlin}
  GoogleMap(
    modifier = Modifier.fillMaxSize(),
    properties = MapProperties(
        mapType = MapType.NORMAL,
        mapStyleOptions = MapStyleOptions(MapStyle.JSON_LIGHT)
    ),
    cameraPositionState = cameraPositionState
) {...}
\end{minted}
\end{listing}

\myparagraph{Impementace motivu mapy}

Aby byla implementace motivů z~kapitoly \textit{Design systém \ref{designSystemImpl}} kompletní, bylo zapotřebí přizpůsobit i mapové podklady tak,
aby se jejich motiv měnil v~závislosti na aktuálním motivu zařízení.

Z~tohoto důvodu a mimo jiné pro zlepšení přehlednosti byly na mapové podklady implementovány určité styly (viz výpis kódu \ref{lst:MapStyle}) \cite{googleStyles}.
Ty jednotlivým částem mapových podkladů přiřazují konkrétní barvy, díky čemuž bylo docíleno jednotnějšího vzhledu. Původní mapové podklady
používaly k~obarvení jednotlivých mapových prvků několik druhů barev a to mělo za důsledek, že na něm byly vyznačené parkovací zóny hůře viditelné.

\begin{listing}[H]
\caption{Motiv mapy ve formátu JSON}\label{lst:MapStyle}
\begin{minted}{json}
  {
    "featureType": "road.highway",
    "elementType": "labels.text.fill",
    "stylers": [
      {
        "color": "#616161"
      }
    ]
  },
  ...
\end{minted}
\end{listing}

\myparagraph{Získaní a zpracování mapových dat}
Mapová data v~podobě seznamu parkovacích zón a jejich podrobnostech jako jsou jednotlivé názvy, typy, popisy a umístění parkovacích zón byla 
získána od města Příbrami. Poskytnutá data byla uvedena ve formátu Keyhole Markup Language (KML), který je primárně určen pro publikaci a 
distribuci geografických dat. Tento formát ke svému zápisu používá syntaxi jazyka XML a z~toho důvodu byl k~jeho převedení do Kotlin objektů 
použit stejný nástroj jako pro převod veškerých dat přicházejících z~informačních systémů města.

Zobrazení parkovacích zón na mapě bylo implementováno pomocí \textit{Composable} funkce Polygon, která je poskytována v~rámci stejného balíčku 
jako dříve zmíněná komponenta \code{GoogleMap}.

Pro vystředění vybrané parkovací zóny na obrazovce byla napsána funkce pro vycentrování mapy tak, aby se zvolená zóna pokaždé 
umístila do středu obrazovky. Implementovaná funkce tedy hledá geometrický střed zadaných souřadnic \( (x_1, y_1), (x_2, y_2), ..., (x_n, y_n)\), 
jenž tvoří mnohoúhelník parkovací zóny a pomocí aritmetického průměrů vypočítává souřadnice středu zóny následujícím způsobem:

\[
\bar{x} = \frac{1}{n} \sum_{i=1}^{n} x_i, \quad \bar{y} = \frac{1}{n} \sum_{i=1}^{n} y_i
\]

Výsledné souřadnice $(\bar{x},\bar{y})$, jsou následně použity k~vycentrování mapy.

\bigskip

Dále byla tato obrazovka rozšířena o~vyhledávací pole, které bylo již možné implementovat v~rámci společné části aplikace. 
To dává uživateli možnost jednoduchého vyhledání parkovací zóny podle názvu nebo čísla parkovací zóny.

Poslední implementovanou komponentou v~rámci obrazovky \textit{Parkování} je takzvaný \textit{Bottom sheet}, který je zobrazen v~případě, 
že uživatel vybere nebo vyhledá parkovací zónu, pro kterou si přeje zobrazit podrobné informace. Konkrétně byl pro implementaci vybrán 
\code{BottomSheetScaffold}, který oproti jeho modálním variantám (např. \code{ModalBottomSheet}), umožňuje souběžnou integraci mezi tímto
 výsuvným panelem a mapovým podkladem.


%\section{Tvorba UI obecně}
\section{Navigace}
Navigace je klíčovou součástí moderních aplikací uživatelského rozhraní, která uživatelům umožňuje pohybovat se mezi různými obrazovkami či 
částmi aplikace. Hlavním cílem navigace je poskytnout uživatelům intuitivní a plynulý způsob průchodu obsahu a samovolně zlepšit jejich provádění akcí v~aplikaci. 

\medskip

Aktuálně však komponenta navigace ze sady knihoven Jetpack Compose není k~dispozici, a proto je potřeba zvolit nějakou alternativu poskytovanou
třetí stranou. \cite{composeNav} Výčet aktuálně doporučených knihoven pro implementaci multiplatformní navigace je uveden v~oficiální Kotlin 
multiplatform dokumentaci a zahrnuje například navigaci Voyager, Decompose nebo Appyx. 

\medskip

K~implementaci byla vybrána navigace Voyager a 
to především díky přehledné dokumentaci, intuitivní implementaci a jednoduchému principu navigace založeném na zásobníku, který pro aktuálně
implementovanou aplikaci plně dostačuje. V~budoucnu by však měla být dostupná i oficiální navigace, ale do té doby je potřeba vybrat z~alternativních knihoven.

\section{Použité technologie}
Následující sekce jsou věnovány konkrétním technologiím, které byly pro tvorbu uživatelského rozhraní použity.
Jedná se o~soubor multiplatformních technologií, které byly převážně použity k~implementaci UI, ale zároveň jsou zde zmíněny některé 
důležité technologie, na kterých je postavena aplikační logika aplikace.

\subsection{Vrstva uživatelského rozhraní}

\subsubsection*{Voyager}
Voyager je multiplatformní navigační knihovna, která umožňuje přecházet mezi různými obrazovkami a destinacemi v~multiplatformních
aplikacích. \cite{voyager} Jejím hlavním cílem je poskytnout jednotné rozhraní především pro navigaci na mobilních platformách jako 
jsou Android a iOS. Voyager zároveň dokáže maximalizovat sdílený kód a snižovat duplikaci kódu.

\medskip

V~rámci implementované aplikace byla navigace Voyager použita především k~implementaci základní navigace mezi jednotlivými obrazovkami.
Příkladem takové navigace jsou například veškeré možné přechody v~rámci domovské obrazovky. Tato navigace vyžívá ke své funkci takzvané 
\textit{Stack API}, jehož implementace funguje na principu zásobníku. S~tím, že pokud uživatel vstoupí na novou obrazovku 
(například přejde na stránku zobrazující detail vybrané události), tak je do tohoto zásobníku přidán odkaz na takzvaný \code{SnapshotState},
který uchovává stav právě opuštěné obrazovky. Znovu obnoven je v~případě, že se uživatel na tuto obrazovku znovu vrátí. Zároveň tento
zásobník slouží k~tomu, aby navigace vždy věděla na jakou stránku se má vrátit (poslední v~zásobníku), když uživatel provede akci zpět
například pomocí tlačítka zpět na platformě Android nebo jakéhokoliv tlačítka zpět implementovaného v~rámci aplikace. \textit{Stack API}
 zároveň umožňuje použití několika funkcí jako jsou například funkce \code{push}, \code{replace}, \code{replaceAll} používané pro průchod vpřed 
 nebo funkce \code{pop}, \code{popAll}, \code{popUntil} pro zpětný návrat. 
Díky této implementaci je možné procházené obrazovky do sebe libovolně zanořovat a v~případě, že je potřeba nějakým způsobem upravit
stav předchozích stavů v~zásobníku, lze nad tímto zásobníkem zavolat některou z~dříve uvedených funkcí.

\medskip

Způsob navigace založený na \textit{Stack API} však není vhodný pro navigování mezi jednotlivými záložkami aplikace (lišta ve spodní 
části obrazovky), a proto je tato část navigace implementována pomocí takzvané \textit{Tab navigation}, kterou knihovna Voyager, taktéž poskytuje.
V~případě použití záložek se průchod obrazovkami nezapisuje do zásobníku, jako tomu bylo v~předchozím případě, ale místo toho poskytuje pouze vlastnost 
\code{current}, díky které je možné nastavit nebo získat aktuální záložku. \cite{voyagerTabNav} 

\medskip

Příklad použití tohoto typu navigace je na následující ukázce kódu \ref{lst:tabNav}, díky které je vidět, jak jsou jednotlivé záložky 
uspořádány v~rámci spodní navigační lišty (funkce \code{BottomNavigation()}).

% založené na zásobníku by byla pro uživatele matoucí.
\begin{listing}[H]
\caption{Ukázka použití navigace založené na záložkách}\label{lst:tabNav}
\begin{minted}{Kotlin}
  TabNavigator(
    tab = HomeTab
  ) {
      Scaffold(
          modifier = Modifier.fillMaxSize(),
          bottomBar = {
              BottomNavigation(
                  backgroundColor = MaterialTheme.colorScheme.background
              ) {
                  TabNavigationItem(HomeTab)
                  TabNavigationItem(EventsTab)
                  TabNavigationItem(ParkingTab)
                  TabNavigationItem(MoreTab)
              }
          },
          content = { CurrentTab() },
      )
  }
\end{minted}
\end{listing}

\subsubsection*{Coil}
Coil je knihovna pro načítání a zobrazování obrázků napsaná v~jazyce Kotlin, která byla původně napsaná pouze pro platformu Android, avšak
od verze 3.0.0 z~prosince roku 2023 existuje alpha verze podporující i platformy JVM, iOS, macOS, nebo Javascript.  

\medskip

Knihovna poskytuje jednoduché API pro načítání obrázků
z~různých zdrojů, včetně URL adres, souborů a zdrojů z~paměti. Díky tomu je integrace obrázků do aplikace snadná a přizpůsobitelná potřebám projektu.
Knihovna Coil dále nabízí automatické dohledávání velikosti obrázků na základě rozměrů zobrazení, což pomáhá optimalizovat paměť a výkon aplikace. Tato funkce 
umožňuje načítat obrázky ve správné velikosti a snižuje zátěž na síťové spojení. Knihovna podporuje širokou škálu formátů obrázků, včetně PNG, 
JPEG, GIF, SVG a WebP, což umožňuje pracovat s~různými typy obrázků bez nutnosti dalšího přizpůsobování.

Další výhodou knihovny Coil je možnost efektivního cachování obrázků, které pomáhá snižovat čas načítání a zlepšuje uživatelský zážitek.

\medskip

V~rámci implementované aplikace jsou téměř všechny obrázky načítány z~URL adres, a proto je možnost cachování zásadní hlavně v~případech, 
kdy aplikace nemá přístup k~internetu.

Pro ukázku \textit{Composable} funkce, která je poskytována knihovnou Coil a byla v~rámci
aplikaci použita k~načítání veškerých obrázků z~internetu, slouží následující výpis kódu \ref{lst:Coil3}.
% TODO placeholder

\begin{listing}[H]
\caption{Composable funkce \code{AsyncImage}poskytovaná knihovnou}\label{lst:Coil3}
\begin{minted}{Kotlin}
  AsyncImage(
    model = news.thumbnailUri,
    contentDescription = "News Image",
    contentScale = ContentScale.Crop,
    modifier = Modifier.aspectRatio(4f / 3f)
  )
\end{minted}
\end{listing}

Kromě těchto druhů navigace byla knihovna Voyager ještě použita k implementaci ViewModelů, které je možné prostřednictvím integrace této knihovny
použít napříč všemi platformami. V případě knihovny Voyager jsou tyto ViewModely nazývány jako \textit{ScreenModels} a podobně jako u klasických
ViewModelů umožňují například uchovat data i při změnách konfigurace (například otočení obrazovky). \cite{voyagerScreeNmodel}

\subsection{Vrstva aplikační logiky}

%\subsubsection*{Kotlin}
%\subsubsection*{Coroutines}
\subsubsection*{Ktor}
Ktor je open-source framework vytvořený společností JetBrains pro tvorbu jak serverových, tak klientských aplikací prostřednictvím programovacího 
jazyka Kotlin. Ktor byl vybrán především kvůli možnosti využití multiplatformního asynchronního HTTP klienta, pomocí kterého je možné zadávat 
HTTP požadavky a zároveň zpracovávat případné odpovědi. 

Pro dotazování byl použit multiplatformní Engine CIO, jehož benefitem je možnost používat Ktor na platformách Android, JVM a všech platformách, které podporuje Kotlin/Native.
\begin{listing}[H]
\caption{Konfigurace HTTP klienta}\label{lst:ktorConfig}
\begin{minted}{Kotlin}
  private val client = HttpClient(CIO) {
    engine {
      maxConnectionsCount = 1000
      requestTimeout = 5000
      ...
    }
  }
\end{minted}
\end{listing}

Po nakonfigurování HTTP klienta je již možné zasílat běžné HTTP dotazy skrze metodu \code{post}, \code{get}, \code{put} nebo \code{delete}.
Na následující ukázce kódu \ref{lst:ktorRequest} je pomocí nakonfigurovaného klienta z~ukázky kódu \ref{lst:ktorConfig} zaslán HTTP požadavek
na webový server města.

\begin{listing}[H]
\caption{Zaslání požadavku}\label{lst:ktorRequest}
\begin{minted}{Kotlin}
  suspend fun getEventsXml(): EventsXmlDto {
    val response: String = client.get("https://kalendar.pribram.eu/...").body()
    return format.decodeFromString<EventsXmlDto>(response.cleanUpEventXml())
  }
\end{minted}
\end{listing}

\subsubsection*{SQLDelight}
SQLDelight je multiplatformní knihovna pro práci s~relačními databázemi v~aplikacích napsaných v~jazyce Kotlin. Jedná se o~moderní knihovnu, 
která umožňuje vytváření a správu SQL dotazů s pomocí typově bezpečných prostředků poskytovaných jazykem Kotlin.

\medskip

Hlavní funkcionalitou knihovny SQLDelight je automatické generování Kotlin tříd a funkcí na základě definovaných SQL schémat. Díky tomu
je možné psát SQL dotazy pomocí standardní SQL syntaxe. SQLDelight se postará o~vygenerování příslušných funkcí v~jazyce Kotlin, které
umožňují  snadný a bezpečný přístup k~databázi. Jediným rozdílem oproti standardním SQL dotazům je označení jednotlivých SQL dotazů takzvaným 
štítkem (viz \code{selectNewestEvents:} ve výpisu kódu \ref{lst:SQLDotaz}), skrze který je vygenerována příslušná Kotlin funkce. 

\begin{listing}[H]
\caption{SQL dotaz pro získání všech novinek v~databázi}\label{lst:SQLDotaz}
\begin{minted}{SQL}
selectNewestEvents:
SELECT *
FROM Events
ORDER BY startDateTime DESC
LIMIT 30;
\end{minted}
\end{listing}

Vygenerované funkce (dotazy) lze následně nalézt ve složce \code{build/generated/sqldelight/...} a pro dotaz z~výpisu kódu \ref{lst:SQLDotaz}
vypadá jeho zkrácená podoba následovně:

\begin{listing}[H]
\caption{SQL vygenerovaný dotaz}\label{lst:SQLGeneratedDotaz}
\begin{minted}{kotlin}
public fun <T : Any> selectNewestEvents(mapper: (
  id: Long,
  categories: String,
  place: String,
  title: String,
) -> T): Query<T> = Query(-704_046_957, arrayOf("Events"), driver, "Events.sq",
    "selectNewestEvents", 
"""
|SELECT Events.id, Events.categories, Events.place, Events.title
|FROM Events
|ORDER BY startDateTime DESC
|LIMIT 30
""".trimMargin()) { cursor ->
  mapper(
    cursor.getLong(0)!!,
    cursor.getString(1)!!,
    cursor.getString(2)!!,
    cursor.getString(3)!!
  )
}
\end{minted}
\end{listing}

I~přesto, že se jedná o~multiplatformní knihovnu a většina kódu tak může být psána v~balíčku sdíleném mezi všemi platformami, je zde i 
část z~následující ukázky kódu \ref{lst:DatabaseDriverFactory}, kterou je pro veškeré implementované platformy potřeba implementovat
nativně. Konkrétně se jedná o~databázové ovladače, k~jejichž implementaci jsou 
zapotřebí nativní knihovny a musí být proto implementovány v~balíčcích jednotlivých platforem.

\begin{listing}[H]
\caption{Nativní databázový ovladač pro platformu \textit{desktop}}\label{lst:DatabaseDriverFactory}
\begin{minted}{kotlin}
actual class DatabaseDriverFactory {
  actual fun createDriver(): SqlDriver {
      val driver: SqlDriver = JdbcSqliteDriver("jdbc:sqlite:AppDatabase.db")
      AppDatabase.Schema.synchronous().create(driver)
      return driver
  }
}
\end{minted}
\end{listing}

\subsubsection*{Koin}
Koin je moderní framework pro vkládání závislostí (zkráceně DI - z~anglického \uv{dependency injection}). Jedná se o~lehkou a snadno 
použitelnou alternativu ke knihovnám jako je například Hilt pro platformu Android.
 %Koin se zaměřuje na jednoduchost použití a minimalismus, což usnadňuje vývoj aplikací a zároveň zlepšuje čitelnost a údržbu kódu.

Hlavním principem Koinu je deklarativní přístup k~definici závislostí pomocí takzvaných modulů. V~modulu se specifikují veškeré závislosti a 
jejich vytváření. Děje se tak prostřednictvím jednoduchých funkcí nebo takzvaných singletons - případně factories. Ty, jak název napovídá, odkazují na 
patřičné návrhové vzory, na jejichž základě se dané instance vytvářejí.


Během této aplikace byl Koin použit například pro vložení databázového ovladače (viz ukázka kódu \ref{lst:KoinInit}), které museli být tvořeny za pomocí expect 
actual deklarací.
Využití DI bylo v tomto případě vhodné předevší proto, že převážná většina databázové logiky je napsána v sdílené 
logice a v~rámci nativní logiky byl tak implementován pouze nativní databázový ovladač. Ten musel být následně pro každou platformu vložen do 
společné třídy implementující Databázi (\code{DatabaseDaoImpl(databaseDriverFactory: DatabaseDriverFactory)}).

Dalšími důležitými komponentami, které byly do aplikace vkládány pomocí DI byly ViewModely a celá třída úložiště, na které jsou ViewModely
závislé.

\begin{listing}[H]
\caption{DI databázového ovladače pomocí Koinu}\label{lst:KoinInit}
\begin{minted}{Kotlin}
  class MainActivity : ComponentActivity() {

  private val dbDriverFactoryModule = module {
      single { DatabaseDriverFactory(applicationContext) }
  }

  init {
      loadKoinModules(dbDriverFactoryModule)
  }
  ...
}
\end{minted}
\end{listing}


%SQLDelight také nabízí silnou typovou kontrolu při práci s daty v databázi. To znamená, že chyby v SQL dotazech jsou odhaleny již při
% kompilaci kódu, což usnadňuje odhalování chyb a zvyšuje stabilitu aplikace.

%\subsection{Full text search impl tech} \label{fulltextSearch}
%TODO
% neco na fulltextové vyhledavani


\section{Logika uživatelského rozhraní} \label{UILayerImpl}
V této sekci je ukázáno, jakým způsobem byla implementována logika chování UI, jejíž části byly navrženy v~kapitole 
\textit{Vrstvy architektury \ref{vrstvyArchitekturySection}}. 


%\textit{Vrstvy architektury \ref{vrstvyArchitekturySection} }, j

\subsection{Stav uživatelského rozhraní} \label{stateHandlingImpl}
Tato sekce slouží k~přiblížení toho, jak je takzvaný \textit{UI State} (z dříve zmíněné kapitoly \ref{vrstvyArchitekturySection}) 
implementován v ukázkové aplikaci.

Z~pohledu UI se jedná o~důležitou část aplikace, o~jejíž aktualizaci se stará později zmíněný ViewModel (viz ViewModel\ref{ViewModelImpl}) neboli ScreenModel v~rámci
implementované aplikace. 
Pro zachování stavu jednotlivých obrazovek byla použita datová třída, která v~sobě umožňuje uchovávat veškeré možné stavy dané obrazovky.
Pro ukázku toho, jak byla taková datová třída implementována, byla vybrána obrazovka událostí (viz výpis kódu \ref{lst:EventState}), která v~sobě 
například uchovává informace typu - jaké filtry událostí jsou aktuálně zvoleny, zdali je otevřeno dialogové okno pro výběr datového rozmezí 
nebo zdali jsou aktuálně načítána nějaká data.
\begin{listing}[H]
\caption{Implementace stavu obrazovky \textit{Události}}\label{lst:EventState}
\begin{minted}{Kotlin}
  data class EventsState(
    val events: StateFlow<List<Event>> = MutableStateFlow(emptyList()),
    val selectedFilterOption: FilterOption = FilterOption.TODAY,
    val isDatePickerOpen: Boolean = false,
    val isFetchingEvents: Boolean = false,
    val filteredEventCategories: List<EventCategory> = emptyList(),
    ...
  )
\end{minted}
\end{listing}

Takto zadefinované stavy je následně možné používat v~rámci jednotlivých obrazovek, které jsou při jakékoliv změně tohoto stavu znovu sestaveny.


%být v~aplikaci použity například následujícím způsobem. Kde stav udržován 
\begin{listing}[H]
\caption{Integrace stavu obrazovkou \textit{Události}}\label{lst:StateImpl}
\begin{minted}{Kotlin}
  val screenModel = getScreenModel<EventsScreenModel>()  // ViewModel
  val state by screenModel.state.collectAsState()
  ...
  FlowColumn {
    state.filteredEventCategories.forEach {
        EventLazyRow(it, state)
    }
  }
\end{minted}
\end{listing}

\subsection{UI události} \label{eventHandlingImpl}
%V~rámci této sekce bude představeno jakým způsobem bylo přistoupeno k implementaci takzvaných \textit{UI Events}.

Jak již bylo zmíněno, tak nejčastějším typem UI události jsou takzvané uživatelské události, produkované uživatelem při interakci s aplikací.
Tyto události jsou zpracovány aplikací pomocí metod jako je například metoda \code{onClick()}, která je často typickým příkladem toho, jak
jednotlivé UI komponenty obsluhují patřičné uživatelské události. 

V přápadě takovýchto metod je pak vhodné uplatnit reprezentaci UI události například v podobě datových objektů 
zadefinovaných ve výpisu kódu \ref{lst:EventsImpl}.

\begin{listing}[H]
\caption{Použití stavu v~aplikaci}\label{lst:EventsImpl}
\begin{minted}{Kotlin}
  sealed interface EventsEvent {
    data object OnFilterTodayIsSelected : EventsEvent
    data object OnFilterDateIsSelected : EventsEvent
    ...
  }
\end{minted}
\end{listing}

Takto zadefinované objekty je již možné použít u UI obrazovek například následujícím způsobem \ref{lst:EventsinUIImpl}.

\begin{listing}[H]
\caption{Použití stavu v~aplikaci}\label{lst:EventsinUIImpl}
\begin{minted}{Kotlin}
  FilterChip(
      onClick = { screenModel.onEvent(EventsEvent.OnFilterTodayIsSelected) },
      label = {
          Text(text = FilterOption.TODAY.filterName)
      },
  )
\end{minted}
\end{listing}

Na ukázce kódu \ref{lst:EventsinUIImpl} je zároveň vidět propojenost UI událostí s příslušným ViewModelem, čemuž se více věnuje následující
sekce \textit{ViewModel}.


%a mohou spustit různé akce, které by zároveň měli způsobit změny UI stavu.

%implementovaná aplikace obsluhuje události přicházející z~uživatelského rozhraní.


%V~rámci ViewModelů jsou obsluhovány události (viz kapitola \ref{UILayerNavrh}), které přichází z~UI elementů. V~jednotlivýmch j

\subsection{ViewModel} \label{ViewModelImpl}
% V~rámci implementované aplikace byl pro každou obrazovku implementován jeden ViewModel, který se stará o~logiku každé obrazovky zvlášť. 
% Tato kapitola bude proto shrnutím stěžejních částí z každého ViewModelů tak aby dávala vhodnou představenu o tom, jako funkci ViewModely
% v aplikaci mají.

V~případě implementované aplikace mají ViewModely jasně definovanou roli a to zpracovávat události přicházející z~UI a na jejich základě 
by vždy měli měnit stav aplikace. \cite{viewmodelEvents} V~tomto duchu jsou implementovány všechny ViewModely. Díky tomu je možné 
zaručit, že stav uživatelského rozhraní nebude změněn například v~důsledku konfiguračních změn. 

Co se implementace jednotlivých ViewModelů týká, tak vesměs všechny mají podobnou strukturu. K vytvoření instance ViewModelu (ScreenModelu)
je zapotřebí dodat příslušnou instanci úložiště (například \code{RepositoryImpl}) a následně je již možné implementovat příslušné funkce
zpracovávající UI události (viz ukázka kódu \ref{lst:ViewModelImpl}). 


\begin{listing}[H]
\caption{Implementace ViewModelu}\label{lst:ViewModelImpl}
\begin{minted}{Kotlin}
fun onEvent(event: EventsEvent) {
    when (event) {
        EventsEvent.OnFilterTodayIsSelected -> {
            screenModelScope.launch {
                val today: LocalDate = Clock.System.todayIn(...)
                ...
                _state.update {
                    it.copy(
                        selectedFilterOption = FilterOption.TODAY,
                        ...
                    )
                }
            }
        }
    }
}
\end{minted}
\end{listing}

%, která ovlivnila implementaci ViewModelů bylo použití navigace Voyager, která poskytuje potřebná rozhraní k 



%\subsection{Implementace mapových podkladů}
