% Do not forget to include Introduction
%---------------------------------------------------------------
\chapter{Úvod}
% uncomment the following line to create an unnumbered chapter
%\chapter*{Úvod}\addcontentsline{toc}{chapter}{Introduction}\markboth{Introduction}{Introduction}
%---------------------------------------------------------------
\setcounter{page}{1}

% The following environment can be used as a mini-introduction for a chapter. Use that any way it pleases you (or comment it out). It can contain, for instance, a summary of the chapter. Or, there can be a quotation.
%\begin{chapterabstract}
%	\lipsum[1]
%\end{chapterabstract}

%\section{Motivace}
\section{Cíle práce} \label{goals}
Prvním důležitým cílem práce je analyzovat použitelnost nově nastupující technologie na poli vývoje multiplatformního UI a otestovat, jaké
nové principy přináší. Dále tuto technologii porovnat s ostatními frameworky pro tvorbu multiplatformního UI a pokusit se
rozebrat důležité principy, na kterých jsou tyto technologie postaveny. 

Další podstatným cílem je vytvoření aplikace, která tuto technologii implementuje a zaměření se při tom na slabé stránky, 
které aktuálně multiplatformní UI provází.

Posledním hlavním cílem je vytvořenou aplikaci otestovat a zhodnotit použitelnost daného frameworku v praxi.

\section{Stručný přehled obsahu práce}
V úvodu se práce zabývá otázkou co to vlastně multiplatformní vývoj je, proč se jím zabývat a jakých zařízení se může týkat.
Dále je probrána otázka v jakých případech se vyplatí aplikovat multiplatformní UI a na jakých zařízeních. 

%a porovnání vazby s UI s logikou daného aplikace vůči multipaltfomovodsti.



%kdy multiplatformí vývoj nemá smysl (vyfocení závady)


Jaké jsou výhody a nevýhody multiplatformních aplikací  v porovnaní s nativními aplikacemi.

Existujícími frameworky a jich porovnáním s Compose Multiplatform.

Detailně rozebrána architektura Compose Multiplatform jak framework funguje a jaké další technologie jsou potřeba k smysluplné implementaci tohoto
frameworku.

Dále je se práce zabývá návrhem a následnou tvorbou multiplatformního UI pomocí frameworku Compose Multiplatform.

V v jedné z posledních části se týká možností testování takto vytvořeného UI a následného testování UI na naimplementované aplikaci.

je věnován shrnutí celého procesu implementace a vyzdvižení naskytlých problémů a výhod oproti nativnímu případně jiným multiplatformním frameworkům



Obecně něco o multiplatformním vývoji.

\section{Definice multiplatformního vývoje UI}

Technologie sloužících k tvorbě multiplatformních UI umožňují vývojářům vytvářet jednotná uživatelská rozhraní, 
která mohou být nasazena na různá zařízení jako jsou mobilní zařízení, tablety, televize, hodinky, obrazovky aut či 
klasické počítače a to buďto v podobě desktopové nebo webové aplikace. Cílem multiplatformního vývoje je tak dosáhnout jednotného 
uživatelského zážitku bez nutnosti psát a udržovat oddělené kódy pro každou platformu. Nicméně jak je vidno z předchozího výčtu zařízení, 
tak ne vždy má smysl multiplatformní přístup aplikovat a tomu kdy je vhodné aplikovat multiplatformní vývoj je věnována následující kapitola.  

\section{Uplatnění multiplatformního vývoje a sdíleného UI}
Aktuálně největší uplatnění multiplatformního UI nabízí mobilní vývoj, kde je díky multiplatformním frameworkům možné vyvíjet
aplikace pro platformy Android a iOS současně. Je tomu tak z důvodu, že mobilní vývoj je aktuálně jeden TODO také díky podobnostem majících na návrh multiplatformního 
UI vliv jako je například velikost obrazovky.

I přesto, že multiplatformní frameworky umožňují implementaci multiplatformním UI na většinu nejvíce používaných platforem jako je Android, iOS,
Android TV, tvOS, Wear OS, watchOS nebo Android Automotive, tak né vždy je vhodné těchto možností využít. Z pohledu UI mají ty platformy často jiné 
velikosti obrazovek, jiné možnosti ovládaní a proto, je často multiplatformní UI a často i veškerá logika implementována konkrétně pro danou platformu
nebo typ zařízení. Je proto vždy nutné vědět jaký typ aplikace bude z pohledu aplikační logiky implementován, jaké budou jeho způsoby užití a na jakých 
platformách bude daná aplikace implementována.

Obecně lze tedy říci, že efektivita implementace multiplatformních aplikaci se může dle těchto omezeních a požadavků výrazně lišit.

%I přesto, že tato práce je věnována především tvorbě UI, tak nesmí být opomenuta aplikační logika, které se za ním skrývá a má UI podstatný vliv.
% Dále zde hrají velkou roli případy užití, které mají na jednotlivá a UI vliv a při multiplatformním vývoji je třeba dbát na jelikož né každá 
% aplikace je z tohoto pohledu vhodná pro multiplatformní

\section{Důvody multiplatformního vývoje a sdíleného UI}

Mezi primární důvody vedoucí firmy a jednotlivce k vývoji multiplatformních aplikací patří především
snížení nákladů na vývoj a následně také na údržbu. Jednodušší dosažení konzistentního vzhledu
na různých platformách nebo například možnost znovu používat komponenty UI na různých platformách.

Mezi další důvody může například patřit možnost rychlejších aktualizací, jelikož nové funkce mohou být 
implementovány jednotně a rychle na všech platformách. 

\chapter{Analýza}
Tato kapitola je zaměřena na představení multiplatformních frameworků a porovnání mezi nimi. 

\section{Přehled existujících frameworků}
Mezi aktuálně nejpopulárnější multiplatformní frameworky jednoznačně patří Flutter a React Native. \cite{crossPlatformFrameworksStats}
V následujících kapitolách jsou proto tyto nejpoužívanější frameworky spolu s frameworkem Compose  Multiplatform podrobněji rozebrány a u každého z nich 
jsou vybrány důležité vlastnosti, které jsou pro tyto frameworky typické. 

Jednotlivé frameworky jsou seřazeny postupně od nejstaršího
po nejmladší, což umožňuje lepší náhled na to, jak se jednotlivé frameworky v čase vyvíjely. Pro lepší ilustraci byla také zvolena 
podobná struktura jednotlivých kapitol, čehož bylo možné docílit díky mnoha společnými rysům napříč frameworky.

%---------------------------------------------------------------
\subsection{React Native}
%---------------------------------------------------------------
React Native byl jedním z prvních frameworků pro tvorbu multiplatformního UI a do jisté míry ovlivnil i ostatní popisované
frameworky. Jeho vývoj započal ve společnosti Facebook během interního hackaton projektu a první jeho oficiálně publikovaná
verze vyšla začátkem roku 2015. \cite{reactNativeHistory}
Nyní se jedná o open-source framework, kde jeho hlavním cílem je umožnit vývojářům vytvářet nativní mobilní aplikace 
pro platformy Android a iOS z jednoho společného kódu napsaného v jazyce JavaScript nebo TypeScript.

\section*{Klíčové vlastnosti React Native}

\myparagraph{Komponentní architektura} 
React Native využívá komponentní architekturu, která vývojářům umožňuje 
vytvářet znovupoužitelné komponenty. \cite{reactNativeComponents} Tato architektura je jednak založena na obecných
React komponentách, ale zároveň také na React Native specifických komponentách, které se dále dělí na takzvané core
komponenty, komponenty vytvořené komunitou či vlastní nativní komponenty. \cite{reactNativeComponents}

% // todo komponenty prekladane na nativni 
    
\myparagraph{Deklarativní zápis UI}
React Native stejně jako React pro webové aplikace využívá pro zápis UI deklarativní způsob, 
při kterém využívá JSX (JavaScript XML) syntaxe k popisu struktury UI komponent. \cite{reactNativeJSX}
Takto zapsané UI lépe reflektovalo aktuální stav aplikace.
Tento způsob zápisu začal na mobilních platformách růst popularitě právě díky Reactu Native, který po svém uvolnění v roce 2013 
defacto nastartoval éru deklarativního zápisu UI na mobilních platformách. \cite{declarativeUIHistory}

\myparagraph{Fast Refresh} 
Fast Refresh je v funkce, která vývojářům umožňuje okamžitě vidět výsledky provedených 
změn v kódu bez nutnosti znovu sestavení aplikace. \cite{reactNativeFastRefresh}

\myparagraph{JavaScript/TypeScript} 
Aplikační logika v React Native se píše v jazyce JavaScript nebo TypeScript, 
což usnadňuje snadnou integraci s existujícími webovými technologiemi. \cite{reactNativeFundamentals}

\myparagraph{Rozsáhlá komunita} 
React Native má rozsáhlou komunitu vývojářů, což vede k bohatému ekosystému 
třetích stran, včetně mnoha dostupných knihoven a modulů. \cite{reactNativeComunity}

\myparagraph{Expo framework} 
Pro ještě snazší start vývoje poskytuje React Native Expo framework, který 
zjednodušuje proces vývoje a umožňuje rychlé prototypování. \cite{reactNativeExpo}

\subsection*{Architektura frameworku React Native}

React native do roku 2022 využíval architekturu založenou na návrhového vzoru Bridge, který spojoval kód napsaný v JavaScriptu s nativní kódem určeným pro danou platformu. 
Tyto dva celky byly spuštěny na souběžných vláknech a komunikovaly spolu pomocí zasílání serializovaných zpráv. Časem se ale ukázalo, že se tato komunikace
a další její charakteristiky stávají úzkým hrdlem celého systému a byla proto od verze 0.68 nahrazena JavaScriptovým rozhraním zvaným JSI. \cite{reactNativeAboutNewArch}

JSI nově JavaScriptu umožňuje držet referenci na C++ objekty a volat nad nimi potřebné metody. \cite{reactNativeAboutNewArch} Toho využívá nový renderovací systém zvaný \textit{Fabric}, který 
frameworku napomáhá sjednotit renderovací logiku prováděnou v C++ a zlepšit tak interoperabilitu s nativními platformami.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth]{react-natice-xplat-implementation-diagram.png}
  \caption{React Native }
  \label{fig:react-natice-xplat-implementation-diagram}
\end{figure}

% \begin{figure}[H]
%   \centering
%   \includegraphics[width=0.55\textwidth]{react-native-data-flow.jpg}
%   \caption{React Native tok dat}
%   \label{fig:react-natice-data-flow}
% \end{figure}


% I přes tyto změny React Native stále využívá systém dvou typů vláken označovaných jako \textit{JavaScript Thread} a \textit{UI Thread} (známé taktéž pod názvem \textit{Main Thread}) 
% mezi které rozděluje práci.


Jak je vidět na obrázku \ref{fig:react-natice-xplat-implementation-diagram}, tak \textit{Fabric} de facto plní funkci prostředníka, který převádí React 
komponenty na nativní komponenty pro každou platformu. 

Pro lepší představu jak dané komponenty vypadají slouží následující ukázka kódu \ref{lst:reactNativeJSX}.

\begin{lstlisting}[caption={Popis UI komponent pomoci JSX}, label={lst:reactNativeJSX}, language=XML]
function MyComponent() {
  return (
    <View>
      <View
        style={{backgroundColor: 'red', height: 20, width: 20}}
      />
      <View
        style={{backgroundColor: 'blue', height: 20, width: 20}}
      />
    </View>
  );
}
// <MyComponent />
\end{lstlisting}

Na ukázce kódu \ref{lst:reactNativeJSX} jsou použity některé z nejpoužívanějších core komponent, které se při psaní React
Native aplikací používají. \cite{reactNativeComponents} Jak již bylo zmíněno dříve, tak tyto komponenty jsou následně převedeny 
na nativní komponenty pro každou platformu a to jakým způsobem Fabric dané komponenty převádí se dá rozdělit do následujících tří
na sebe navazujících fází: \cite{reactNativeRenderCommitMount}
 
%Na této ukázce je zároveň vidět použití deklarativního zápisu, které bude podrobněji probráno v následující kapitole.

\smallskip

\myparagraph{Render}
Během této fáze se z jednotlivých komponent (React Elementů) sestaví strom elementů v JavaScriptu (viz levá část obrázku \ref{fig:react-native-render-pipeline}) a nad tímto stromem se 
následně spustí rekurzivní redukce, při které dojde k vytvoření nového stromu takzvaného React Shadow Tree. (viz prostřední část obrázku \ref{fig:react-native-render-pipeline})
\cite{reactNativeRenderCommitMount} Ten se skládá z jednotlivých React Shadow Nodes, které reprezentují objekty v C++ a tím přechází tato renderovací fáze do další fáze zvané commit.\cite{reactNativeRenderCommitMount}

\myparagraph{Commit}
V rámci této fáze je pro každý React Shadow Node vypočítána jeho pozice a velikost na koncovém zařízení a díky tomu může renderovací systém
přejít k poslední fázi zvané Mount. \cite{reactNativeRenderCommitMount}

\myparagraph{Mount}
Během této poslední fáze dojde k transformaci \textit{React Shadow Tree} na \textit{Host View Tree} (viz pravá část obrázku \ref{fig:react-native-render-pipeline}) a to tak, že každý \textit{React Shadow Node}
se transformuje na jeho ekvivalent v nativní podobě. \cite{reactNativeRenderCommitMount} Čili například na platformě Android se $<ViewShadowNode>$ přetransformuje na android.view.ViewGroup. \cite{reactNativeRenderCommitMount}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.99\textwidth]{react-native-render-pipeline.png}
  \caption{React Native vykreslovací fáze}
  \label{fig:react-native-render-pipeline}
\end{figure}

%---------------------------------------------------------------
\subsection{Flutter}
%---------------------------------------------------------------
Flutter je open-source softwarový toolkit pro vývoj uživatelských rozhraní (UI). \cite{flutterfaq} Za vývojem stojí společnost Google a je určený k vytváření nativně kompilovaných 
aplikací pro mobilní zařízení, web a desktop z jednoho zdrojového kódu. \cite{flutterfaq}
Byl vydán v roce 2017 a získal značnou popularitu mezi vývojáři díky svému snadnému použití, flexibilitě a schopnostem tvorby UI.

\subsection*{Klíčové vlastnosti Flutteru}

\myparagraph{UI založené na widgetech} 
Flutter využívá reaktivně deklarativní UI založené na widgetech. \cite{flutterUI} Widgety jsou základními stavebními 
bloky Flutter aplikací, představující vše od strukturálních prvků po stylistické komponenty. \cite{flutterWidgets}

\myparagraph{Hot Reload} 
Další z významných funkcí Flutteru, která významně zrychluje vývojový proces a zvyšuje produktivitu je funkce "Hot Reload". 
Během vývoje běží Flutter aplikace na virtuálním počítači (Dart VM), který díky této funkci umožňuje okamžitě vidět provedené změny
v kódu bez nutnosti úplné rekompilace aplikace. \cite{flutterHotReload} Teprve pro vydání jsou Flutter aplikace kompilovány přímo do strojového kódu, 
ať už jde o instrukce Intel x64 nebo ARM, případně do JavaScriptu pokud jsou cíleny na web. \cite{flutterArchOverview}


\myparagraph{Jeden zdrojový kód pro více platforem} 
S Flutterem mohou vývojáři psát jeden zdrojový kód pro obě platformy Android a iOS, což snižuje dobu vývoje a úsilí 
vynakládané na údržbu. Flutter také rozšířil svou podporu pro cílení webových a desktopových aplikací, umožňující širší dosah s minimálními změnami kódu. \cite{flutter}

\myparagraph{Rozsáhlá sada widgetů}
Flutter poskytuje komplexní sadu přizpůsobitelných widgetů, které usnadňují vytváření složitých a vizuálně 
atraktivních uživatelských rozhraní. Tyto widgety zahrnují vše od základních tlačítek a textových polí až po 
pokročilé komponenty jako jsou grafy a animace. \cite{flutterWidgets2}

\myparagraph{Programovací jazyk Dart}
Aplikace vytvořené pomocí frameworku Flutter jsou psány v jazyce Dart, moderním objektově orientovaném programovacím jazyce 
vyvinutém společností Google. Dart je navržen pro optimální výkon a produktivitu, což ho činí vhodným pro mobilní a
webový vývoj. \cite{dart}

\myparagraph{Způsob renderovaní UI}
Na rozdíl od Reactu Native Flutter nepoužívá platformě specifické komponenty koncových zařízení, ale veškeré UI komponenty (widgety)
renderuje pomocí vlastního renderovacího enginu. \cite{flutterRenderingModel}


\subsection*{Architektura frameworku Flutter} 
Jak je vidět na obrázku \ref{fig:flutter_architectural_layers}, tak architektura Flutteru je rozdělena do tří hlavních vrstev. \cite{flutterArchOverview}
Embedder je vrstva, která umožňuje integrovat Flutter do konkrétních platforem jako je Android, iOS, desktop nebo web. 
Každý embedder obsahuje platformě specifický kód, který je potřebný pro spuštění Flutteru na dané platformě.
Engine je vrstva starající se o vykreslování grafiky, kdykoli kdy je potřeba vykreslit nový snímek. \cite{flutterArchOverview} 
Framework je vrstva, která je používána vývojáři k vytváření uživatelských rozhraní a definování chování aplikace. 
Obsahuje hotové widgety, funkce pro manipulaci s UI a další nástroje pro vývojáře. \cite{flutterArchOverview} 


\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth]{flutter_architectural_layers.png}
  \caption{Flutter architectural layers}
  \label{fig:flutter_architectural_layers}
\end{figure}

Mezi hierarchicky poslední a neméně důležitou častí tohoto frameworku jsou platformě specifické knihovny Material and Cupertino. Tyto knihovny
jsou následně využívány widgety k implementaci konkrétního design systému. Díky tomu je možné uživateli navodit nativní pocit z dané aplikace.

\medskip

Z pohledu UI je důležitým prvkem právě Flutter framework, který zároveň definuje jak spolu jednotlivé widgety interagují.

Widget je ve Flutteru základní stavební blok pro tvorbu uživatelského rozhraní. \cite{flutterWidgets} V následující ukázce kódu \ref{lst:flutterCode} je pro příklad použito několik 
základních widgetů jako je \emph{Image} nebo \emph{Text} a taktéž layout widget zvaný \emph{Container} a \emph{Row} pro organizaci a 
rozložení vnořených widgetů na obrazovce.

\begin{lstlisting}[caption={Popis UI widgetů pomocí jazyka Dart}, label={lst:flutterCode}, language=Kotlin]
  Container(
  color: Colors.blue,
  child: Row(
    children: [
      Image.network('https://www.example.com/1.png'),
      const Text('A'),
    ],
  ),
);
\end{lstlisting}

Když Flutter potřebuje vykreslit tento blok, zavolá metodu \emph{build()} a ta vrátí podstrom widgetů, které následně vykreslí uživatelské 
rozhraní na základě aktuálního stavu aplikace. \cite*{flutterArchOverview}

Během fáze sestavování překládá Flutter widgety vyjádřené v kódu (například kód \ref{lst:flutterCode}) do odpovídajícího stromu elementů viz obrázek \ref{fig:flutter_trees}, přičemž každý widget má jeden element a 
každý prvek představuje určitou instanci widgetu v daném umístění stromové hierarchie. \cite*{flutterArchOverview}


\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{flutter_trees.png}
  \caption{Flutter build proces}
  \label{fig:flutter_trees}
\end{figure}



\subsection{Compose Multiplatform}

Compose Multiplatform je framework sloužící k tvorbě uživatelských rozhraní použitelných na vícero platformách za 
jehož vývojem stojí společnost JetBrains. \cite{composeMultiplatform} Je založen na toolkitu zvaném Jetpack Compose, který je aktuálně 
doporučovaný k tvorbě nativních uživatelských rozhraních na platformě Android. \cite{jetpack}

Podporuje platformy jako Android, iOS (Alpha), Windows, MacOS, Linux a Web (experimentální). \cite{composeMultiplatform}

\medskip

\subsection*{Klíčové vlastnosti Compose Multiplatform}

\myparagraph{Deklarativní zápis UI} 
Používá deklarativní syntaxi pro popis uživatelského rozhraní. \cite{KMPUseCases}

\myparagraph{Jednotný kód pro různé platformy} 
Možnost sdílet kód pro Android, iOS, web i desktop. \cite{composeMultiplatform}

\myparagraph{Snadné migrace díky postupné integraci} 
Díky KMP je možné postupně implementovat jednotlivé částí aplikace i do již existujících aplikací s minimálním rizikem oproti
ostatním multiplatformním technologiím. \cite{KMP}

\myparagraph{Znovupoužitelnost Kotlin kódu} 
Díky KMP je možné použít některé části kódu z již existujících Android aplikací i na ostatních platformách.

\myparagraph{Programovací jazyk Kotlin} 
Frontendová i backendová část aplikace jsou psány v jazyce Kotlin pro bezproblémovou integraci se serverovou částí.

\myparagraph{Podpora od JetBrains}
Poskytuje stabilní podporu od vývojářského týmu JetBrains.

\subsection*{Architektura frameworku Compose Multiplatform} \label{ComposeArch}
Jelikož je framework Compose Multiplatform z velké části založen na frameworku Jetpack Compose, tak v této kapitole bude probírána
právě architektura toho frameworku, která bude doplněna o drobné rozdíly mezi těmito dvěma frameworky.

V porovnání s ostatními dříve zmíněnými frameworky slouží tento framework pouze k tvorbě multiplatformního UI a z toto důvodu je převážně 
používán s toolkitem Kotlin Multiplatform, který dané aplikaci poskytuje i multiplatformní aplikační logiku. Jelikož se jedná o základní 
komponentu bez které by Compose Multiplatform nevznikl, tak je tomuto toolkitu věnována celá kapitola \ref{kmpSection}.

Pro lepší ukázku toho, z jakých částí se typická multiplatformní mobilní aplikace skládá slouží následující obrázek \ref{fig:composeIOS}, který
vizualizuje propojenost frameworku Compsose Multiplatfom s toolkitem Kotlin Multiplatfom (KMP). Dále vizualizuje 
vztah platformě specifických knihoven pro tvorbu UI jako SwiftUI k frameworku Compose Multiplatform.
Compose Multiplatform lze nicméně použít i s technologiemi pro tvorbu UI jako je UI kit pro platformu iOS nebo
Android views  pro platformu Android, od kterých je postupně upouštěno a přechází se k deklarativním frameworkům jako je Jetpack Compose nebe SwiftUI.  

\begin{figure}[H]
  \centering
  \includegraphics[width=.7\textwidth]{composeIOS.png}
  \caption{Compose Multiplatform iOS}
  \label{fig:composeIOS}
\end{figure}

TODO % doplnit neco o KMP a APIs

Co se týče samotného UI kódu, tak ten se skládá z jednotlivým funkcí označených anotací \code{@Composable}, která v těle obsahuje další
\textit{Composable} funkce (viz výpis kódu \ref{lst:ComposeCode}) jako jsou například \code{Column} pro strukturování vnořených elementů do sloupce nebo \code{Text} pro zobrazení
textu na obrazovce. 

\begin{lstlisting}[caption={Popis UI widgetů pomocí jazyka Kotlin}, label={lst:ComposeCode}, language=Kotlin]
@Composable
fun MyComposable() {
    Column {
        Text("Hello")
        Text("World")
    }
}
\end{lstlisting}

Takto strukturovaný kód může být následně frameworkem vykreslen na obrazovku k čemuž dochází v těchto třech následujících fázích:

\myparagraph{Composition}
Během této fáze Jetpack Compose vytvoří stromovou strukturu reprezentující UI komponenty, které mají být vykresleny.\cite{jetpackPhases} 
Tato stromová struktura je tvořena na základě do sebe zanořených Composable funkcí, které představují jednotlivé prvku uživatelského rozhraní.
Lepé tutu skutečnost reprezentuje obrázek \ref{fig:semantics-ui-tree}, na kterém je vidět, že nejspodnější vrstvu UI, reprezentuje kořenový uzel
sémantického stromu a následující vnořené prvky jsou jeho potomky.

\begin{figure}[H]
  \centering
  \includegraphics[width=.5\textwidth]{semantics-ui-tree.png}
  \caption{UI struktura a její sémantický strom}
  \label{fig:semantics-ui-tree}
\end{figure}

\myparagraph{Layout}
Během této fáze se jednotlivým komponentám určí na jakých pozicích se mají vykreslit a jakou mají mít šířku a výšku.
Compose během této fáze prochází strom UI komponent tak, že nejprve změří velikost svých potomků (pokud existují) a následně se 
na základě těchto měření rozhodně o vlastní velikosti. Nakonec umístí každého potomka relativně ke své pozici.\cite{jetpackPhases}

Díky použití tohoto algoritmu je k prostupu celého stromu zapotřebí navštívit každý uzel pouze jednou, což je výhodné jelikož
s přibývajícími uzly roste čas potřebný k průchodu celého stromu pouze lineárně. \cite{jetpackPhases}

\myparagraph{Drawing}
V rámci poslední fáze dochází s samotnému vykreslení komponent na obrazovku koncového zařízení. \cite{jetpackPhases}
Compose během této fáze znovu postupně prochází strom UI elementů od kořene až do listů a každý element tohoto stromu vykreslí sám sebe 
na pozici určenou během Layout fáze. \cite{jetpackPhases}

\subsubsection{Kotlin Multiplatform} \label{kmpSection}


%https://blog.jetbrains.com/kotlin/2023/11/kotlin-multiplatform-stable/#use-the-power-of-the-growing-kotlin-multiplatform-ecosystem

Kotlin Multiplatform je často základním kamenem pro tvorbu multiplatformních aplikací založených na Compose Multiplatform a to
z toho důvodu, že díky KMP je možné implementovat multiplatformní aplikační logiku, která může doplňovat multiplatformní UI 
poskytované frameworkem Compose Multiplatform. \cite{KMPUseCases} Důležitým rozdílem oproti ostatním multiplatformním frameworkům 
je právě ta možnost, kterou KMP případně Compose Multiplatform vývojářům poskytuje. 

Jelikož se jedná o SDK, tak umožňuje vývojářům implementovat multiplatformní funkcionality postupně, bez nutnosti implementovat 
v Kotlinu celé vrstvy aplikací. Díky tomu dává vývojářům možnost sdílet napříč platformami je ty části kódu, které mají největších
smysl implementovat pro veškeré platformy a zbylé části kódu psát v nativním jazyce pro danou platformu. \cite{KMP}
Lépe je tato skutečnost ilustrována na následujícím obrázku \ref{fig:KMP_vrstvy}, na kterém jsou vidět různé možnosti,
jakými může být KMP na daných platformách implementován.

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{KMP_vrstvy.png}
  \caption{Možnosti implementace KMP}
  \label{fig:KMP_vrstvy}
\end{figure}

Zároveň je tento obrázek ukázkou toho, jak může probíhat migrace z již naimplementované nativní aplikace na aplikaci
multiplatformní. Nejprve je tedy možné implementovat jen malou část aplikační logiky pro víro platforem a postupem času přesouvat
do multiplatformní části aplikace například celé vrstvy starající se o prezentační, datovou nebo jinou aplikační logiku. \cite{KMPUseCases}

Aby ale k takové migraci mohlo dojít, tak je zapotřebí aby pro technologie používané v původní nativní aplikaci existovali multiplatformní
knihovny nebo alespoň jejich ekvivalent.

\subsubsection*{Multiplatformní knihovny}
Společnost JetBrains ve svém článku z konce roku 2023 zmiňuje, že existuje již přes 1500 KMP knihoven s tím, že ještě v roce 2020
jich bylo pouze několik málo desítek. \cite{KMPstable}

%Jeho hlavním úkolem je sdílení kódu na mobilních platformách. 
Právě počet a vyspělost těchto knihoven se podle společností, které již KMP používají jeví jako zatím jedna z nejslabších stránek KMP (viz kapitola \ref{kmpInPractise}).

V případě, že žádná vhodná knihovna není k dispozici, tak je zde stále možnost čehož je možné docílit díky funkcionalitě jazyka Kotlina
zvané Expected a actual deklarace.

\subsubsection*{Expected a actual deklarace}\label{expectActual}
Deklarace \textit{expected} a \textit{actual} umožňují přistupovat k platformě specifickým API z Kotlin Multiplatform modulů. \cite{KMPExpectActual}
Nejprve je ve společné části potřeba vytvořit například třídu nebo funkci u které chceme aby její obsah byl implementován typicky pomocí
platformě specifických knihoven a tuto část v rámci společného modulu označit klíčovým slovem \code{expect}. \cite{KMPExpectActual} Její implementaci následně provést v rámci
platformě specifického kódu. Tato implementace musí být provedena pod stejným názvem a ve stejném balíku jako deklarace ve společném modulu
a musí být označena klíčovým slovem \code{actual}. \cite{KMPExpectActual}

Během kompilace pak Kotlin kompilátor každou deklaraci s klíčovým slovem \code{expect} sjednotí s příslušnou actual deklarací pro danou platformu
a vygeneruje z ní jednu deklaraci obsahující actual implementaci. \cite{KMPExpectActual}

\subsubsection*{Struktura KMP projektů}\label{projectStructure}
TODO


\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{kotlin-multiplatform-hierarchical-structure.png}
  \caption{Hierarchická struktura KMP}
  \label{fig:KMP_struktura}
\end{figure}

\subsubsection*{Aktuální použití KMP v praxi} \label{kmpInPractise}
% Mezi další důvody patří taktéž lepší zastupitelnost jednotlivých členů týmu a to díky me

I přesto, že je KMP ve stabilní verzi teprve od listopadu 2023 \cite{KMPstable}, tak tuto technologii používá již několik světově 
známých firem v produkčním nasazení jako je například Forbes či McDonald's. Forbes uvádí, že právě díky KMP dokáží sdílet až 80 \%
aplikační logiky napříč platformami Android a iOS. \cite{KMPinForbes} 
Druhý ze jmenovaných McDonald's jako hlavní výhody uvádí jednodušší testování \cite{KMPinMcDonalds}

Naopak mezi největší výzvy, které obě společnosti ve svých souhrnech uvádějí patří adaptace na KMP prostředí (především iOS vývojářů) nebo
nedostatečné množství potřebných multiplatformních knihoven (případně jejich nedostatečná vyspělost). \cite{KMPinForbes} \cite{KMPinMcDonalds}

Pro porovnání 

\emph{"Od této doby jsme vyvinuli a v produkci provozujeme několik mobilních aplikací. Ze zkušenosti vidíme, že při jejich vývoji dokážeme sdílet cca 60–70 \% kódu na platformu. V případě vývoje na dvě platformy to znamená, že v součtu dokážeme ušetřit minimálně třetinu nákladů na vývoj, plus s tím související další náklady na věci typu testování (v tomto případě snížení až na polovinu)."}

\begin{figure}[H]
  \centering
  \includegraphics[width=.7\textwidth]{chart-KMP-vs-native.png}
  \caption{Množství kódu KMP vs native}
  \label{fig:KMP_vs_native}
\end{figure}

Pro upřesnění je ještě potřeba zmínit, že veškeré vyjmenované společnosti, využili pouze možnosti sdílení logiky a nepoužívají
tak sdílené UI pomocí Compose Multiplatform.

To se ukázalo i na průzkumu, který provedla společnost JetBrains v roce 2021, kde pouze 3,8~\% respondentů odpovědělo, že byli schopni sdílet UI ve svých aplikacích.

Pro ukázku veškerých částí, které respondenti sdíleli ve svých aplikacích napříč platformami slouží obrázek \ref{fig:KMPSurvey}, který jednoznačně ukazuje, že
mezi nejčastěji sdílené části aplikací patří datová a síťová vrstva.  

\begin{figure}[H]
  \centering
  \includegraphics[width=.99\textwidth]{survey-results-q1-q2-22.png}
  \caption{KMP průzkum}
  \label{fig:KMPSurvey}
\end{figure}

\section{Flutter vs React Native vs Compose Multiplatform}


\subsection{Porovnání výkonu}

Mezi klíčové parametry, kvůli kterým většina firem upřednostňuje vývoj nativních aplikací, patří především výkon
nativních aplikací. Z toho důvodu se následující podkapitola věnuje právě porovnání výkonu a dalších parametrů multiplatformních aplikací s
nativními verzemi aplikací. 

Pro testování byly použity toolkity pro tvorbu nativního UI pro platformu Android (Jetpack Compose) a iOS (SwiftUI)
v porovnání s multiplatformním frameworkem Compose Multiplatform a aktuálně nejpoužívanějším multiplatformním
frameworkem zvaném Flutter. \cite{crossPlatformFrameworksStats} 

Mezi hlavní testované parametry patřil čas nastartování testované aplikace a její velikost.

\subsection*{Ukázková aplikace}
Pro porovnání důležitých parametrů byla pro test vytvořena jednoduchá aplikace, která obsahovala jednu obrazovku, 
načetla obrázky z veřejného API a zobrazila je v horizontálním seznamu. 
Na každý obrázek šlo kliknout a zobrazit jej přiblížený pod seznamem. 

Veškeré testy proběhli na zařízeních Pixel 4a a iPhone 12 Mini a byly opakovány celkem pětkrát.

%Verze Compose Multiplatform 1.4

% replikovat test


\myparagraph{Velikost aplikace} 

Na obrázku \ref{fig:chart_app_sizes} je vidět, že velikost aplikace založené na Compose Multiplatform je identická
s velikostí nativní aplikace pro Android. Je tomu tak z toho důvodu, že výsledná aplikace pro Android neobsahuje kód 
pro jiné platformy. \cite{} Kdežto u velikosti iOS aplikace je situace výrazně jiná. Samotná aplikace pro iOS je v porovnání
s její nativní aplikací o 23,1 MB větší. Tento rozdíl ve velikosti je způsoben především grafickou 2D knihovnou Skia,
která je na platformě Android dostupná, kdežto na platformě iOS ne a proto tam musí být spolu s aplikací dodána. \cite{}

Zajímavé je následné porovnání s velikostí aplikace založené na frameworku Flutter, jelikož ta, stejně jako Compose
Multiplatform využívá knihovnu Skia, ale i přesto je o něco menší než Compose Multiplatform aplikace na platformě iOS.
Součástí aplikace Flutter ještě vlastní engine, který je součástí aplikace a zvětšuje tak velikost aplikace asi o 3–4 MB pro Android a 10 MB 
pro iOS. \cite{flutterSize}

\begin{figure}[H]
  \centering
  \includegraphics[width=.7\textwidth]{chart_app_sizes.png}
  \caption{APK/IPA size in megabytes}
  \label{fig:chart_app_sizes}
\end{figure}

\myparagraph{Rychlost spuštění aplikace}

Při porovnání rychlosti spuštění Compose Multiplatform aplikace na platformě Android není mezi rychlostmi téměř žádný
rozdíl stejně tak jako tomu při porovnání velikosti aplikací v předchozí kapitole. O něco delší dobu spuštění měla
aplikace napsaná pomocí frameworku Flutter, která se spouštěla v průměru o 221 ms déle než Compose Multiplatform aplikace. 
Toto zpomalení je s nejvyšší pravděpodobností způsobeno dobou spuštění Flutter Enginu, což by korespondovalo s oficiální
Flutter dokumentací. \cite{flutterPerformance}

U posledního porovnání na platformě iOS se doba spuštění aplikací založených na Compose Multiplatform a frameworku 
Flutter o tolik nelišila od nativní aplikace.
% // TODO posledni cast porovnani

% // TODO posledni tabulka pro porovnani https://github.com/jacobras/flutter-vs-native-vs-kmp

\begin{figure}[H]
  \centering
  \includegraphics[width=.7\textwidth]{chart_startup_times.png}
  \caption{Časy nastartování jednotlivých aplikací}
  \label{fig:chart_startup_times}
\end{figure}

\subsection{Náročnost implementace}
I přesto, že je náročnost implementace do jisté míry subjektivní záležitostí, tak existuje několik aspektů, které mohou k porovnání 
náročnosti implementace Compose Multiplatform s ostatními frameworky posloužit. 

TODO

\section{Limitace Compose Multiplatform oproti nativnímu řešení} 
% to se tyka KMP ne compose Multiplatform
Jak již bylo zmíněno v kapitole KMP, tak jedním z největších problému multiplatformního vývoje pomocí KMP je
především nedostatečné množství knihoven. 

Co se týče UI, tak zde je situace díky možnosti využití Jetpack Compose o něco lepší. Většina omezení, která jsou
aktuálně spjata s UI se týká především plynulosti a nebo použití nativně vypadajících komponent na platformě iOS.
Ta v její nativní podobě používá styl zvaný Cupertino, který frameworkem Compose Multiplatform není aktuálně oficiálně podporován. 
Co se týče plynulosti UI na platformě iOS, tak aktuálně se nejvíce řeší problém s rychlostí vykreslování.

Většina výše zmíněných problémů se již řeší a je zmíněna v Kotlin Multiplatform vývojářském plánu pro rok 2024. \cite{KMPRoaddMap} Konkrétně
se jedná o veškeré zmíněné o problémy kromě zařazení HarmonyOS mezi podporované platformy.% // todo 
V tomto plánu je mimo jiné uvedeno, že aktuální prioritu číslo jedna je dostání frameworku Compose Multiplatform na platformě iOS do verze Beta. \cite{KMPRoaddMap}

\chapter{Návrh}
V rámci této kapitoly bude nejprve vybrána aplikace, která bude použita k otestování použitelnost Compose Multiplatform frameworku a následně
bude tato aplikace navržena tak, aby splnila veškeré vytyčené cíle z úvodní kapitoly \textit{Cíle práce \ref{goals}}.

Po vybrání typu aplikace následuje podkapitola věnující návrhu vhodných případů užití, které je vhodné specifikovat jednak aby bylo zřejmé jací 
uživatelé budou danou aplikaci používat, tak z pohledu na jakých zařízení případně platformách ji budou využívat. 
Zároveň vhodné skloubení případů užití s grafickou podobou UI, tak aby nejčastější uživatelovi cílem bylo možné splni s co nejmenší dávkou úsilí, 
je pro správný návrh UI klíčové. 
což obecně vede k intenzivnějšímu používaní a oblibě aplikace.


Další fáze návrhu je věnována vytyčení funkčních požadavků ...

Dále je v rámci této kapitoly navržena architektura aplikace, která je pro následné navržení a správné fungování UI nezbytná. 

Podkapitola \textit{Návrh architektury} se tedy věnuje rozebrání používaných typů architektury pro mobilní zařízení a následnému detailnímu
rozebrání jednotlivých vrstev vybrané architektury.

V poslední části návrhu je přistoupeno k samotné návrhu uživatelského rozhraní aplikace a to nejprve za použití takzvaných wireframe modelů,
následně návrhu design systému a nakonec k návrhu konečné podoby UI včetně grafických prvků.



\section{Výběr aplikace pro implementaci}
Základním požadavkem bylo vybrat takovou aplikaci, ve které by bylo možné použít velké množství různých komponent, jejichž funkčnost by následně mohla být otestována
na různých platformách.
%které by bylo možné použít napříč různými platformami.
Mezi další požadavky patřilo zaměření se na kritické problémy, které aktuálně multiplatformní vývojem provází. 
Mezi takové problémy patří například využití funkcí, které jsou silně spjaty s hardwarem koncových zařízení jako je použití jednotné navigace, fotoaparátu 
nebo služeb lokalizace.

Z těchto důvodů byla k implementaci vybrána aplikace sloužící pro občany měst či obcí, která kombinuje veškeré funkční požadavky, které plynou ze zadání.

Tato aplikace by sloužila občanům k získání informací o aktuálních novinkách, pořádaných akcích nebo by jim například umožňovala vyhledat a zaplatit parkovné.
TODO rozsirit uvodni popis aplikace provest analyzu co by takova apk mela obsahovat

Na základě toho popisu byli vybrány následující případy užití.

\section{Případy užití}
Případy užití (use cases) jsou scénáře popisující, jakým způsobem by případní uživatelé aplikace mohli využívat určité funkce nebo
vlastnosti aplikace k dosažení svých cílů. \cite{} Tyto scénáře zachycují interakce mezi uživatelem a systémem a popisují, jak systém reaguje na určité vstupy od 
uživatele. Zároveň popisují jakou zpětnou vazbu uživatel na základě provedených vstupů od systému dostává.

Každý případ užití obvykle obsahuje následující prvky:

\begin{itemize}
  \item Název: Stručný název, který popisuje, co uživatel chce dosáhnout.
  \item Aktor: Uživatel nebo systém, který spouští případ užití.
  \item Popis: Podrobný popis scénáře, který obsahuje kroky, které uživatel vykonává, a odpovědi systému na tyto kroky.
  \item Předpoklady: Podmínky nebo situace, které musí být splněny, aby mohl být případ užití spuštěn.
  \item Výsledek: Očekávaný výsledek akce provedené uživatelem.
\end{itemize}

\myparagraph{UC1 Zobrazení aktuálních novinek} 
Tento případ užití popisuje jak mohou občané prostřednictvím aplikace získat přístup k aktuálním novinkám a důležitým oznámením ze svého města 
nebo obce. Tato funkce umožní občanům zůstat informováni o dění ve svém okolí.

\begin{enumerate}
  \item Systém uživateli zobrazí aktuální seznam aktualit z webových stránek města a dalších informačních zdrojů.
  \item Uživatel si vybere aktualitu, která ho zaujme.
  \item Systém uživateli zobrazí detail vybrané aktuality obsahující její název, obsah, datum vytvoření, obrázek a případně odkazy na další zdroje.
\end{enumerate}

\myparagraph{UC2 Zobrazení aktuálních událostí} 
Tento případ užití popisuje jak mohou občané prostřednictvím aplikace získat přehled o aktuálně připravovaných akcích, událostech a kulturních 
aktivitách v jejich městě nebo obci. 

\begin{enumerate}
  \item Systém uživateli zobrazí aktuální seznam událostí z webových stránek města, divadel, kin a dalších informačních zdrojů.
  \item Uživatel si vybere událost, která ho zaujme.
  \item Systém uživateli zobrazí detail vybrané události obsahující její název, popis, datum konání, místo konání obrázek a případně odkazy na další zdroje.
\end{enumerate}

\myparagraph{UC6 Filtrování zobrazených událostí za základě času}
Tento případ užití popisuje jak mohou občané filtrovat zobrazené události podle na základě datu konání daných událostí.

\begin{enumerate}
  \item Systém uživateli zobrazí seznam událostí z webových stránek města, divadel, kin a dalších informačních zdrojů s nejbližším datem konání, který 
  je rozdělen na základě kategorií jako například kino, divadlo, hudba atd..
  \item Uživatel si vybere konkrétní den pro který chce zobrazit konané události.
  \item Systém uživatel vrátí výpis pro vybraný den a události rozdělí na základě kategorií, do kterých vyfiltrované události spadají.
\end{enumerate}

\myparagraph{UC3 Zobrazení kontakty na místní úřady}
Aplikace může poskytovat možnost rychlého a snadného získání kontaktu na místní úřady nebo správními orgány. %Uživatelé budou moci prostřednictvím aplikace zasílat otázky, stížnosti nebo žádosti o pomoc a získávat odpovědi a podporu přímo ze svého mobilního zařízení.

\begin{enumerate}
  \item Systém uživateli zobrazí seznam městských institucí.
  \item Uživatel vybere konkrétní instituci, pro kterou chce zobrazit detailní informace.
  \item Systém vrátí podrobné informace o vybrané instituci.  
\end{enumerate}

\myparagraph{UC4 Nahlášení závady ve městě}
Aplikace dá občanům možnost hlásit závady, které je potřeba ve městě opravit.

\begin{enumerate}
  \item Systém uživateli zobrazí formulář pro k vyplnění městských institucí.
  \item Uživatel vyplní název závady, nahraje fotografii závady, vyplní místo, kde se závada nachází, vybere kategorii závad do, které závada spadá a 
  záznam o závadě odešle.
  \item Systém závadu odešle příslušnému orgánu a uživateli vrátí informaci o 
  
  \item TODO rozdvojka spatne dobre vyplnene
\end{enumerate}

\myparagraph{UC5 Propojení s YouTube kanálem města}
Aplikace dá občanům možnost konzumovat aktuální novinky prostřednictvím videí z městského YouTube kanálu. Díky intuitívnímu propojení...

\begin{enumerate}
  \item 
  \item 
\end{enumerate}

\myparagraph{UC7 Vyhledání parkovacích zón}
Aplikace umožňuje občanům města jednoduše a rychle vyhledat veškeré parkovací zóny ve městě včetně informace o provozní době parkovací zóny.

\begin{enumerate}
  \item Systém uživateli zobrazí mapu parkovacích zón ve jeho obci.
  \item Uživatel vybere parkovací zóny pro kterou chce zobrazit detailní informace.
  \item Systém vrátí uživateli detailní informace týkající se vybrané parkovací zóny.
\end{enumerate}

\myparagraph{UC8 Platba parkovného}  podTask UC7
Aplikace umožní uživatelům snadno a rychle zaplatit parkovné prostřednictvím svého mobilního zařízení. Uživatelé mohou zadat informace o svém vozidle, 
délce parkování a provedení platby online, což jim ušetří čas a nepohodlí spojené s hledáním parkovacího automatu nebo mincí.

\begin{enumerate}
  \item Systém uživateli zobrazí mapu parkovacích zón ve jeho obci.
  \item Uživatel vybere parkovací zóny pro kterou chce zaplatit parkování.
  \item Systém vrátí uživateli detailní informace týkající se vybrané parkovací zóny s odkazem na zaplacení.
  \item Uživatel na detailu vybrané zóny vybere akci zaplatit parkovné.
  \item Systém uživatele přesměruje na platební systém používaný daným městem pro platbu parkovného s předvyplněnou informací o vybrané parkovací zóně.
\end{enumerate}

\myparagraph{UC7 Zobrazení dopravy na mapě města}
Tento případ užití popisuje jak mohou občané města jednoduše a rychle zobrazit vytíženost silnice ve městě.

\begin{enumerate}
  \item Systém uživateli zobrazí mapu vytíženost silnice ve městě.
\end{enumerate}



Pro dotvoření představy o tom jak jsou spolu jednotlivé případy užití navzájem propojeny slouží obrázek \ref{}, na který zároveň 
obasuje i typy uživatelů pracujících s navrženou aplikací.

Co se týče vzájemných vazeb, tak zde je věno

Use case diagram
\begin{figure}[H]
  \centering
  \includegraphics[width=.99\textwidth]{Use case diagram.png}
  \caption{Use case diagram}
  \label{fig:use_case_diagram}
\end{figure}

\section{Role}

TODO jaci uzivatel budou aplikaci použivat



Případy užití jsou klíčovým nástrojem pro pochopení potřeb uživatelů a návrhu funkcionalit aplikace tak, aby co nejlépe odpovídaly těmto potřebám. 
Jsou také důležitým zdrojem pro testování a validaci funkčnosti aplikace, protože je na jejich základě možné ověřit, zda systém správně reaguje na očekávané 
uživatelské interakce. 

Na jejichž základě je proto založeno koncové testování celé aplikace čehož je využito k tvorbě UI testů v kapitole \textit{Testování \ref{testsSection}}.

Na základě takto sepsaných případech užití je nyní možné sepsat funkční požadavky.

\section{Funkční požadavky}
Funkční požadavky definují konkrétní vlastnosti a chování aplikace, které zajistí, že bude aplikace pro občany měst či obcí 
užitečná, efektivní a snadno použitelná.

TODO

\myparagraph{Zobrazení novinek}
Možnost přidávat, editovat a mazat novinky a oznámení.
Zobrazení aktuálních novinek na domovské obrazovce aplikace.
Možnost filtrovat novinky podle kategorie nebo data.

\myparagraph{Zobrazení událostí}
Zobrazení kalendáře s událostmi, akcemi a důležitými daty.
Možnost procházet události v kalendáři dle data, místa nebo typu události.
Možnost přidávat nové události do kalendáře.
Možnost filtrovat události podle kategorie nebo data.

\myparagraph{Platební brána pro parkovné}
Možnost provádět platby parkovného prostřednictvím aplikace.
Zadání informací o vozidle, parkovacím místě a délce parkování.
Zobrazení historie plateb a možnost platit opakovaná parkování.

\myparagraph{Možnost vyhledání a kontaktování místních úřadů, policie nebo zdravotního střediska}
Zobrazení kontaktních informací a pracovní doby úřadů.
Možnost zaslat otázku, stížnost nebo žádost přímo prostřednictvím aplikace.

\myparagraph{Navigace a mapy}
Integrace mapových služeb pro zobrazení umístění událostí a místních služeb.
Možnost vyhledávání tras a navigace v rámci města nebo obce.

\myparagraph{Podpora více jazyků}
Možnost nastavení jazyka aplikace dle uživatelských preferencí.
Zobrazení obsahu a textů v různých jazycích.

\myparagraph{Feedback a hodnocení}
Možnost zaslat zpětnou vazbu, hodnocení nebo recenzi na aplikaci.
Zpětná vazba od uživatelů a možnost sledovat spokojenost s aplikací.


\myparagraph{Pokrytí případů užití} 
Pro ověření, že takto sepsané funkční požadavky pokrývají všechny případy užití byla vytvořena následující tabulka pokrytí.

\begin{table}[b]
  \centering
  \begin{tabular}{|l|c|c|c|c|c|c|c|c|}
  \hline
  %\multicolumn{9}{|c|}{Functional Requirements} \\ \hline
   & F1 & F2 & F3 & F4 & F5 & F6 & F7 & F8  \\ \hline
  UC1  & $\ast$ &        &        &        &        &        &        &         \\ \hline
  UC2  & $\ast$ &        &        &        &        &        &        &         \\ \hline
  UC3  & $\ast$ &        &        &        &        &        &        &         \\ \hline
  UC4  &        & $\ast$ &        &        &        &        &        &         \\ \hline
  UC5  &        &        &        & $\ast$ &        &        &        &         \\ \hline
  UC6  &        &        & $\ast$ &        &        &        &        &         \\ \hline
  UC7  &        &        &        &        & $\ast$ & $\ast$ & $\ast$ & $\ast$  \\ \hline
  UC8  &        &        &        &        &        & $\ast$ & $\ast$ & $\ast$  \\ \hline
  UC9  &        &        &        &        &        &        &        & $\ast$  \\ \hline
  UC10 &        &        &        &        &        &        &        & $\ast$  \\ \hline
  UC11 &        &        &        &        &        &        &        & $\ast$  \\ \hline
  \end{tabular}
  \caption{Pokrytípřípadů užití funkčními požadavky aplikace}
  \label{table:tabulkaPokryti}
\end{table}
  

\section{Návrh architektury}
Navržená architektura se z velké části drží architektonických principů shrnutých v Android dokumentaci. \cite{andDocArch}

TODO možné architektury pro vyvoj mobilních aplikací

\subsection*{Důležité principy}

\myparagraph{Separation of concerns}
Separation of concerns je princip návrhu softwaru, který popisuje důležitost oddělení různých funkcionalit do samostatných, dobře definovaných a izolovaných částí.
Hlavním cílem tohoto principu je zlepšit modularitu, udržitelnost, znovupoužitelnost a spravovatelnost kódu.

Princip oddělení zájmů rozděluje systém na jednotlivé komponenty nebo moduly, přičemž každý z nich se zabývá jednou konkrétní 
oblastí funkcionality. Každá část systému má jasně definované rozhraní, které umožňuje interakci s ostatními částmi. 
Tímto způsobem lze snadněji spravovat a udržovat kód, protože změny v jedné části systému nemusí mít nežádoucí dopady na ostatní části.

Příklady oddělení zájmů zahrnují oddělení prezentační vrstvy od logiky aplikace (Model-View-Controller), oddělení datového přístupu od 
podnikové logiky (Repository pattern), a oddělení různých vrstev aplikace (např. vrstva uživatelského rozhraní, aplikační logika, datová vrstva). 

\myparagraph{Unidirectional Data Flow}
Unidirectional Data Flow (jednosměrný tok dat) je architektonický vzor, který popisuje způsob, jakým data cestují skrz aplikaci. 
V tomto přístupu data proudí v jednom směru, což znamená, že existuje jasný a jednoznačný tok dat od zdroje až po jejich konečný cíl.
Takovýto přístup například umožňuje efektivní aktualizaci uživatelského rozhraní v reakci na změny dat a přispívá k jednoduchosti, 
předvídatelnosti a údržnosti softwarových aplikací.

\myparagraph{Single source of truth}
Princip Single Source of Truth (SSOT) je koncept v softwarovém inženýrství, který zdůrazňuje, že v aplikaci by měl existovat jediný 
zdroj dat, který obsahuje aktuální a spolehlivé informace. Tento zdroj dat je považován za „pravdivý“ a slouží jako jediný zdroj, 
ze kterého mohou ostatní části aplikace čerpat informace. Tím se zajišťuje konzistence dat napříč aplikací a minimalizuje se riziko 
konfliktů nebo chyb v datech.

Díky použití principu SSOT jsou data v aplikaci konzistentní a snadněji spravovatelná, protože všechny komponenty a moduly aplikace pracují se stejnými 
daty. To usnadňuje údržbu a vývoj aplikace, protože úpravy a aktualizace dat lze provádět centrálně. Z hlediska kódu přispívá tento
princip k jednoznačnosti a přehlednosti, protože vývojáři vědí, kde hledat relevantní data pro různé části aplikace.

Cílem tohoto konceptu je zlepšit konzistenci, přehlednost a údržbu aplikace a poskytnout spolehlivý zdroj dat pro všechny části aplikace.


\subsection{Vrstvy architektury} \label{vrstvyArchitekturySection} 
TODO % takzvaná architektura MVVM?  ..., která uplatňuje výše zmíněné principy.
Na základě těchto principů vznikla níže popsaná architektura, která je aktuálně doporučovaná pro vývoj mobilních Android aplikací.

Ta se rozděluje do následujících třech vrstev:

\subsubsection*{UI vrstva} \label{UILayerNavrh}
UI vrstva se stará o zobrazení dat na obrazovce, která odpovídají aktuálnímu stavu aplikace. Zároveň se stará se logiku, která
se při změně těchto dat stará o opětovné překreslení UI, tak aby opět odpovídalo aktuálnímu stavu aplikace. Tohoto chování UI vrstva 
dociluje pomocí tří částí, které jsou zobrazeny na obrázku \ref{fig:arch_ui_udf} a následně detailněji popsány pod ním.

\begin{figure}[H]
  \centering
  \includegraphics[width=.5\textwidth]{arch-ui-udf.png}
  \caption{Architektura UI vrstvy}
  \label{fig:arch_ui_udf}
\end{figure}

\myparagraph{ViewModel}
Hlavní účel ViewModelu je uchovávat a spravovat data potřebná pro zobrazení na obrazovce, a to i při změnách konfigurace zařízení 
(například při otáčení obrazovky). ViewModel také poskytuje metody a události pro interakci s daty, jako je načítání dat ze zdroje, 
jejich aktualizace a předávání událostí od uživatele zpět do aplikace. Na základě těchto událostí například aktualizuje stav uživatelského
rozhraní. % (UI elementů) nebo stavu 

\myparagraph{UI state} \label{UIStateParagraph}
UI state (stav uživatelského rozhraní) je částí UI vrstvy, který popisuje aktuální stav a chování uživatelského 
rozhraní v daném okamžiku. Tento stav může zahrnovat různé informace, jako jsou aktuální hodnoty vstupních polí, stav vybraných prvků,
 aktuální zobrazené obrazovky nebo panely, stav animací a další.

UI state je důležitý pro udržování konzistence a interaktivity uživatelského rozhraní. Změny v UI stavu mohou být způsobeny uživatelskými
interakcemi jako například kliknutím na tlačítko, zadáním textu do pole, rolováním seznamu nebo mohou být vyvolány událostmi v aplikaci,
jako je získání dat ze serveru nebo jakoukoliv změnou interního stavu aplikace. 

V rámci frameworků, které k tvorbě UI používají deklarativní způsob zápisu, se často k definice stavu a jeho vlivu na UI používá funkce 
na obrázku \ref{fig:UI_function}, která zjednodušeně popisuje to, že na základě stavu je tvořeno výsledné uživatelské rozhraní.

\begin{figure}[H]
  \centering
  \includegraphics[width=.5\textwidth]{ui-equals-function-of-state.png}
  \caption{Reprezentace vztahu UI a stavu aplikace}
  \label{fig:UI_function}
\end{figure}

Správa UI stavu je důležitou součástí vývoje aplikací s uživatelským rozhraním a může být implementována pomocí různých technik a nástrojů.
Důležité je udržovat UI stav v souladu s interním stavem aplikace a zajistit jeho konzistenci a správnou aktualizaci v reakci na uživatelské 
interakce a události v aplikaci.

\myparagraph{UI Elements}
UI elements neboli prvky uživatelského rozhraní jsou komponenty tvořící vizuální část aplikace a umožňují uživatelům interagovat s aplikací.
Tyto prvky zahrnují různé vizuální komponenty, jako jsou tlačítka, textová pole, seznamy, obrázky, ikony, přepínače, posuvníky atd. díky nimž
se zobrazují data reprezentující aktuální stav aplikace nebo je pomocí nich tento stav měněn.

UI prvky jsou navrženy tak, aby poskytovaly uživatelům intuitivní způsob, jak s aplikací komunikovat a manipulovat. Každý prvek má své 
vlastnosti, jako jsou velikost, barva, text, stav atd., které lze nastavit a upravovat pomocí kódu. Tyto prvky jsou pak umístěny na obrazovce 
podle určeného rozvržení (layout), které určuje jejich pozici a vzájemné uspořádání.

UI prvky jsou základními stavebními bloky uživatelského rozhraní a hrají klíčovou roli při vytváření uživatelsky přívětivé a atraktivní aplikace. 
Jejich vhodné použití a umístění má vliv na celkový uživatelský zážitek a efektivnost aplikace.

\subsection*{Doménová vrstva}
Doménová vrstva typicky obsahuje způsoby užití nicméně pro menší aplikace jako je tato může být vynechána. 

V tomto projektu doménovová vrstva zahrnuje deklarace výčtových typů, objektů pro datovou a modelou vrstvu a mapovací funkce pro pro převod
objeků datové vrstvy na objekty používané v prezentační vrstvě a naopak.

Doménová vrstva by měla být nezávislá na technických aspektech aplikace a měla by se zaměřovat pouze na reprezentaci a správu doménových
 konceptů a procesů. To zjednodušuje testování, údržbu a rozšíření aplikace a umožňuje snadnou změnu technologií nebo platformy bez 
 vlivu na doménovou logiku.

\subsection*{Datová vrstva}
Datová vrstva se stará o veškerá 
The data layer that contains the business logic of your app and exposes application data.


Datová vrstva je klíčovou součástí softwarových systémů, která se zabývá persistencí dat a komunikací s datovými úložišti, jako jsou
 databáze, soubory nebo vzdálené API. Jejím hlavním úkolem je poskytovat rozhraní mezi doménovou logikou aplikace a datovými zdroji, 
 aby bylo možné ukládat, načítat, aktualizovat a mazat data podle potřeby.



\begin{figure}[H]
  \centering
  \includegraphics[width=.5\textwidth]{data_layer_diagram.png}
  \caption{Architektura datové vrstvy}
  \label{fig:arch_data_layer}23
\end{figure}

% \begin{figure}[H]
%   \centering
%   \includegraphics[width=.3\textwidth]{data_layer_diagram_principle.png}
%   \caption{Architektura datové vrstvy}
%   \label{fig:arch_data_layer_principle}
% \end{figure}

Mezi důležité prvky datové vrstvy patří:

\myparagraph{DAOs}
DAOs jsou zodpovědné za přímý přístup k datovým úložištím a provádění operací jako čtení, zápis, aktualizace a mazání dat. Tyto objekty 
poskytují abstrakci nad konkrétními technologiemi datových úložišť a umožňují snadnou změnu úložišť bez vlivu na ostatní části aplikace.

\myparagraph{DTOs}
DTOs jsou objekty používané k přenosu dat mezi vrstvami aplikace. Tyto objekty slouží k přenosu dat mezi datovou vrstvou a doménovou 
vrstvou a často mapují datové entity na jednodušší objekty nebo struktury pro snadnější manipulaci.

\myparagraph{Datové entity}
Datové entity představují strukturu a schéma dat uložených v databázi nebo jiném datovém úložišti. Tyto entity obvykle přímo odrážejí
strukturu tabulek v relační databázi nebo dokumentů v NoSQL databázi a poskytují model, se kterým mohou pracovat ostatní vrstvy aplikace.

\myparagraph{Datová úložiště}
Datové úložiště jsou fyzická místa, kde jsou data uložena. Mohou to být relační databáze, NoSQL databáze, soubory na disku nebo externí API. 
Datová vrstva zajišťuje, aby bylo možné efektivně pracovat s těmito úložišti a aby byla data bezpečně uložena a získána.

\bigskip

Tyto vrstvy jsou spolu propojeny následujícím způsobem.

\begin{figure}[H]
  \centering
  \includegraphics[width=.8\textwidth]{arch_diagram.png}
  \caption{Provázanost jednotlivých částí datové vrstvy}
  \label{fig:arch_diagram}
\end{figure}

\bigskip

Po shrnutí dosavadně zmíněních poznatků týkajících se architektury aplikace byly jednotlivé vrstvy převedeny do jednotlivých balíků s následující
strukturou:

\dirtree{%
.1 data\DTcomment{datová vrstva}.
  .2 model\DTcomment{}.
  .2 repository.
.1 ui\DTcomment{prezentační vrstva}.
  .2 composables\DTcomment{}.
  .2 screens\DTcomment{}.
    .3 HomeScreen\DTcomment{}.
}
\bigskip



% \dirtree{%
%         .1 src \DTcomment{}.
%           .2 androidMain \DTcomment{}.
%           .2 commonMain \DTcomment{je pro kód sdílený mezi všemi platformami}.
%             .3 kotlin \DTcomment{}.
%               .4 data\DTcomment{datová vrstva}.
% 		            .5 model\DTcomment{}.
% 		            .5 repository.
% 		          .4 ui\DTcomment{prezentační vrstva}.
% 		            .5 composables\DTcomment{}.
% 		            .5 screens\DTcomment{}.
% 		              .6 HomeScreen\DTcomment{}.
%             .3 resourses \DTcomment{}.
%           .2 desktop Main \DTcomment{}.
% 	}


% \begin{figure}[H]
%   \centering
%   \includegraphics[width=1\textwidth]{mvvm.png}
%   \caption{MVVM with Clean Architecture}
%   \label{fig:mvvm}
% \end{figure}

\section{Návrh UI}

\section{Tvorba drátových modelů}
K tomu aby bylo výsledné UI pro uživatele přívětivé bylo přístupováno tak aby co nejvíce  s pravidly dobrého návhu UI.

Mezi takoví pravidla patří:
TODO

Navržené drátové modely byly vytvořeny na základě funkčních požadavků a to tak, aby nejdůležitější a nejčastěji používané funkce byly 
umístněny na domovkou obrazovku. A zbylé méně podstatbé nebo prostorově náročnější byli umístěny na sekundární obrazovky.

Zároveň byla snaha o 

\pagebreak


\myparagraph{Domovská obrazovka}
\begin{wrapfigure}{r}{0.4\textwidth}
  \centering
  \includegraphics[width=0.35\textwidth]{home_wireframe.png}
  \caption{Wireframe domovské obrazovky}
\end{wrapfigure}

Jak již bylo zmíněno v úvodu této kapitoli, tak domovská obrazovka obsahuje většinu nejdůležitější a 

Na základně...byla pro události vybrána možnost zobrazení jednotlivých událostí ve skrolovacím řádku a to především z důvodu,
 že akce poutají především svým vizuálním největší část informace je uživateli předána právě pomocí titulního obrázku, názvu
a času konání.

Oproti tomu pro seznam novinek ve sopdní části obrazovky bylo vybráno uspořádání novinek do scrolovancího sloupce, který lépe umožňuje 
vyžít celou šíři obrazovky k zobrazení delších titulků a textů událostí, které josu pro uživatele v případě aktualit nejdůležitější.

Mezi další UI prvky na domovské obrazovce patří tlačítka v její horní části, která uživateli umožňují rychlý proklik na YouTube kanál města,
nahlášení závady, zobrazení uředních hodin a kontaktů.

%V horní části se nachzí sekce umožňující přidání vlastní 

%další čast obrazovky je věnována popolárním udáslostem, které jsou vybráná na základě ...

\myparagraph{Obrazovka událostí}

\begin{wrapfigure}{r}{0.4\textwidth}
  \centering
  \includegraphics[width=0.35\textwidth]{events_wireframe.png}
  \caption{PoWireframe obrazovky události}
\end{wrapfigure}

V rámci obrazovky "Události" je použit stejný systém pro zobrazené údálostí pomocí skrolovaního řádku jako je tomu na domovské obrazovce.

Oproti domovské stránce jsou zde však zobrazeny veškeré události, které se ve městě budou konat. Pro lepší přehled jsou udáslosti rozděleny 
do několika málo kategorií.

V hoorní části aplikce je uživateli dána možnost vybrat den pro který chce zobrazit plánované udáslosti, případně zvolit požadované rozmezí.

%jako například Kino, Divadlo, Celodenní akce, akce pro děti, přednášku atd.


Byla navžena tak aby uživatelé mohli jednoduše filtrovat zobrazované události přmárně podle času.

filtrování podle kategorie bylo nejprve navrženo ale následně z neho bylo umuštěno kvůli malému počtu kategorií.

byl zvolen přístup, který vybrané události přiřadí do patřičné kategorie a zobrzí jen ty kategorie, které obsahují alespoň jednu událost.

veškeré kategori se zobrzí na maximalně 3 straánkách což se ukázalo

\myparagraph{Obrazovka parkování}

\begin{wrapfigure}{r}{0.4\textwidth}
  \centering
  \includegraphics[width=0.35\textwidth]{parking_wireframe.png} 
  \caption{Wireframe obrazovky parkování}
\end{wrapfigure}

Obrazovká parkovaní slouží uživateli především k vyhledání parkovací zóny, získání informací o ceně parkování případně k platbě parkovného.

Aby bylo docíleno co nejjednuším manipulace s mapovými podklady byl prostor obrazovky navržen tak aby hlavní část byla věnována přávě mapovému
podkalu na němž jsou vyznačeny parkovancí zóny. 

Pro usnadnění hledání parkovacích zón dává aplikace uživateli možnost vyhlenání požadovaná parkovací zóny pomocí vyhledávací pole, které 
uživateli umožňujě vyhledat příslušnou parkovancí zónu buďto podle čísla nebo názvu zóny. 

Dále zde byla implentována výsuvná karta ze spodní části obrazovky, která se zobrazí pouze v případě, že uživatel vyberere nějakou
z nabízených parkovacích zón. Nezmenšuje tak uživateli prostor pro rychlé vyhledání parkovanící zóny, které je hlavním cílem k použití této obrazovky. 

Tato výsuvná karta uživateli zobrazí detailní informace k vybrané parkovancí zoně a dá uživateli možnost zaplatit parkovné.

Poslední funkci, kterou tato obrazovka nabízí je zobrazení aktuálního provozu ve městě. 



\myparagraph{Obrazovka více}
\begin{wrapfigure}{r}{0.4\textwidth}
  \centering
  \includegraphics[width=0.35\textwidth]{more_wireframe.png} 
  \caption{Wireframe obrazovky více}
\end{wrapfigure}

Poslední navrženou obrazovkou je obrazovka "Více", která obsahuje přehled veškerých funkcí aplikace a zároveň obsahuje veškeré méně podstatné 
časti aplikace.

Jelikož je ale aplikce cílena pro široké spektrum lidí, byl zde navžena funkce, která umožnuje přidání vybraného prvku na domovskou obrazovku.


který uživatelům umožňuje přízpůsobení domovské obrazovky.
při dlouhém stisknnutí zobrazí možnost přidání prvku na domovskou obrazovku.
které mohou být přidány na uvodní obrzovku.


v případě, že by uživatel shledal některou 
z nabízených funkcí důležitější/častěji potřebnou, tak umožňnuje uživateli tuto funkci přidat na domovskou obrazovku.

Představuje rychlo naviga

Obsahuj důležité prvky aplice, které obsahují veškeré méně podstatné časti aplikace.



\section{Návrh design systému} \label{designSystemSection}
Před tím něž bylo přistoupeno ke grafickému návrhu aplikace, tak byl vytvořen obecný design systém, který poslouží k vytvoření 
konzistentního uživatelského rozhraní. Zároveň se díky němu urychlí proces navrhovaní grafické podoby UI a při následné fázi implementace 
zajistí intuitivní ovládání aplikace na všech platformách. 

%Design system je obecně vzato sada komponent, pravidel, principů a návrhových postupů, které slouží k vytváření konzistentního
%uživatelského rozhraní a uživatelského zážitku napříč různými aplikacemi a platformami. 

Design systém je obecně vzato sada předem definovaných pravidel, komponent, standardů a návrhových principů, které slouží k vytváření a udržování 
konzistentního a jednotného vizuálního stylu v rámci celé aplikce. Takový systém tak zahrnuje různé prvky jako jsou barvy, typografie, ikony,
layouty a komponenty uživatelského rozhraní a umožňuje vývojářům a designérům efektivně spolupracovat a vytvářet aplikace s jednotným 
vzhledem. 
 
Cílem návrhu design systému je zajistit, aby všechny části aplikace měly jednotný vzhled a chování, což zlepšuje předvším uživatelskou 
zkušenost s implementovanou aplikací. 
%Designový systém zároveň často obsahuje sadu prvků UI, typografického stylu, barev, ikon a další informace, které 
%pomáhají designérům a vývojářům při tvorbě aplikací.

%V navrhovaní výslednéh design systému bylo přistupováno tak aby styl navržených UI komoponenty, typů písma, barem a dalších prvků design 
%systému přiblině odpovídal aktuálně používanému stylu města.

%Jelikož město, které bylo vybráno pro implementaci aplikace nikde expliciteně nedefinovalo používaný design systém,
%byl proto vytvořen na základě. 
%TODO NEBO 

V rámci vybraného města Příbrami není takový systém nikde expliciteně zadefinovaný a proto byl odvozen z designu webových stránek města.
pro navození maximálního pocitu jednoty s dosavadními informačními systémy města.

Zároveň byl zkobinovaný s aktuálně nejnovějším design systémem od společnosti Google zvaným Material 3, který se hodí nejen pro použití
na mobilních platformách.

S ohledem na to, že aplikce je navrhována pro použití na mobilních zařízením, tak je tomu uzpůsoben i návrh samotné design systému, který
specifikuje především prvky použitelné na mobilních platformách a zbylé části mohou být případně v budoucnu rozšířený o další prvky 
používané na jiných platformách.

V tomto případě bylo navrženo pár základních UI prvků, které budou použity v rámci této aplikace a mouhou být použity i případně dalšími 
aplikací města.

Výsledek základní ukázky takto navrženého systému je k vidění na obrázku \ref{fig:design_system}

\begin{figure}[H]
  \centering
  \includegraphics[width=.99\textwidth]{design_system.jpg}
  \caption{Vytvořený design systém}
  \label{fig:design_system}
\end{figure}

\section{Návrh mockup modelu} \label{navrhMockupModelu}
Po zadefinování použitelných komponet v navženém design systému \ref{designSystemSection} jež samotný návrh grafické podoby UI zjednodušen 
na nezbytné minimum. 

Vytvořené mockup modely jsou defacto výsledkem sloučení dratových modelů s navrženým design systémem.

\begin{figure}[H]
  \minipage{0.4\textwidth}
    \includegraphics[width=\linewidth]{screen1.png}
    \caption{Domovská obrazovka}
  \endminipage\hfill
  \minipage{0.4\textwidth}
    \includegraphics[width=\linewidth]{screen2.png}
    \caption{Obrazovka \textit{Události}}
  \endminipage\hfill
\end{figure}

\begin{figure}[H]
  \minipage{0.4\textwidth}
  \includegraphics[width=\linewidth]{screen3.png}
  \caption{Obrazovka \textit{Parkování}}
\endminipage\hfill
\minipage{0.4\textwidth}
  \includegraphics[width=\linewidth]{screen4.png}
  \caption{Obrazovka \textit{Více}}
\endminipage\hfill
\end{figure}

\chapter{Implementace}
Stejně tak jako v případě vývoje Android aplikací, tak k sestavování multipaltformích aplikací založených na Compose Multiplatform 
se používá nástroj zvaný Gradle.  

\section{Gradle}
Gradle je open-source nástroj pro automatizaci sestavení a správu závislostí při vývoji softwaru. Je to nástroj pro automatizaci sestavení 
podobný Antu nebo Mavenu, který byl vyvinut pro zjednodušení procesu sestavení a nasazení softwaru.

Gradle používá deklarativní doménově specifické jazyky (DSL), díky kterým umožňuje definovat sestavení a konfiguraci projektu pomocí srozumitelné
a flexibilní syntaxe. Od verze 3.0 z roku 2016 je možné psát Gradle skripty v jazyce Kotlin DSL a od roku 2023 je Kotlin DSL primarním jazykem 
pro jejich zápis. To umožňuje vývojářům snadno konfigurovat sestavení a spravovat závislosti na knihovnách a modulech v jazyku se stejnou
syntaxí jako je používána pro ostatní části projektu.

%K vytvoření projektu založeném na Compose Multiplatform je doporučeno využití právě totoho sestavovacího nástoroje. 

K tomu aby bylo možné Compose Multiplatform v projektu použít, je zapotřebí do projektového souboru \code{build.gradle.kts} přidat Compose 
Multiplatform plugin (viz výpis kódu \ref{lst:ComposePlugin}).

\begin{lstlisting}[caption={Integrace Compose Multiplatform pluginu do sestavovacího scriptu}, label={lst:ComposePlugin}, language=Kotlin]
plugins {
  id("org.jetbrains.compose") version "1.6.0"
}
\end{lstlisting}
Dále je zapotřebí vybrat platformy pro které má být aplikace určena a podle nich vytvořit příslušné balíčky viz kapitola \ref{}.
Podle těchto balíčků se následně v příslušném \code{build.gradle.kts} vytvořit takzvané \code{sourceSets}, díky kterým je možné
pro každou platformu (balíček) implementovat platformě specifické závislosti. Tyto závislosti se následně vkládají do příslušných
sourceSets podle toho zdali se jedna o multiplatformní (commonMain) nebo nativní závislost (androidMain, iosMain, atd.).

Pro ukázky jak taková multiplatformní závislost může vypadat slouží ukázka kódu \ref{lst:LibIntegration}, díky které je do projektu
přidána knihovna umožnující implementaci multiplatformní navigace.

\begin{lstlisting}[caption={Lib integration}, label={lst:LibIntegration}, language=Kotlin]
sourceSets {
  commonMain.dependencies {
    implementation(libs.voyager.navigator)
    ...
  }
}
\end{lstlisting}

Dále je potřeba do spouštěcích souborů každé platformy integrovat multiplatformní část aplikace, která může být do nativního kódu přidána
například pomocí \textit{Composable} funkce, která je napsána v rámci sdílené části aplikace.

Ve výpisu kódu \ref{lst:SharedIntegration} je touto funkcí funkce \code{App()}, která je volána z nativního Android kódu a stará se
o deklaraci veškerého multiplatformního UI.

\begin{lstlisting}[caption={Lib integration}, label={lst:SharedIntegration}, language=Kotlin]
class MainActivity : ComponentActivity() {

  override fun onCreate(savedInstanceState: Bundle?) {
      super.onCreate(savedInstanceState)

      setContent {
          App()
      }
  }
}
\end{lstlisting}

Stejným způsobem je potřeba integrovat tuto funkci i do ostatních spouštěcích souborů. 



Jelikož časem projekt obsahuje je vhodné pro správu verzí použít takzvaný version katalog. 

\myparagraph{Gradle version catalog}
Gradle version catalog je obyčejní soubor ve formátu TOML, který umožňuje snadněji přidávat a spravovat závislosti a pluginy ve celém projektu. 
Místo ručního přidávání závislostí a pluginů do každého modulu zvlášť je možné shromáždit veškeré závisloti v tomto souboru a zadefinovat rovněž
verzi, která má být pro tento modul použita napříč celým projektem. 

Příklad toho jak mohou být dříve zmíněné závislosti přepsány do version
katalogu je uveden ve výpisu kódu \ref{lst:VersionCalalog}.

\begin{lstlisting}[caption={Version katalog}, label={lst:VersionCalalog}, language=Kotlin]
[versions]
compose-plugin = "1.6.0"
voyagerVersion = "1.0.0"

[libraries]
voyager-navigator = { module = "cafe.adriel.voyager:voyager-navigator", 
                      version.ref = "voyagerVersion" }
[plugins]
jetbrainsCompose = { id = "org.jetbrains.compose",
                     version.ref = "compose-plugin" }

\end{lstlisting}

\section{Tvorba UI obecně}
\subsection{Navigace}
Navigace je klíčovou součástí moderních aplikací uživatelského rozhraní, která uživatelům umožňuje pohybovat se mezi různými obrazovkami či 
částmi aplikace. Hlavním cílem navigace je poskytnout uživatelům intuitivní a plynulý způsob průchodu obsahu a provádění akcí v aplikaci. 

Aktuálně však komponenta navizage ze sady knihoven Jetpack Compose není k dispozici a proto je potřeba zvolit nějakou alternativu poskytovanou
třetí stranou. \cite{composeNav} Výčet aktuálně doporučených knihoven pro implementaci multipaltformí navigace je uveden v oficiálních Kotlin 
multiplatform dokumentaci a zahrnuje navigace Voyager, Decompose nebo Appyx. K implemnaci byl po zvážení nakonec vybrána navigace Voyager a 
to především díky přehledné dokumentaci, intuitivní implementaci a jednoduchému principu navigace založeném na zásobníku, který pro aktuálně
implementovanou aplikaci plně dostačuje.

V budoucu by však měla být dostupná, ale do té doby je potřeba vybrat z alternativních knihoven.



%\section{Navigace a lokalizace v implementaci}
\subsection{Implementace design systému}

Při implementace design systému pomocí Compose Multiplatfom byla snaha co nejpřesněji napodobit navržený design sytém z kapitoly \ref{designSystemSection}
tak aby uživateli navodil maximalní pocitu jednoty s dosavadními informačními systémy města.


Compose multiplatform je přípraven na implementaci design systému. 

loading


\subsubsection{Barvy}
Barvy byly zvoleny na základě vizuálního stylu města, které město Příbram využívá při všech prezentačních příležitostech.

Pro použití výbraných barev v aplikaci bylo zapotřebý jednotlivé barvy zadefinovat následujícím způsobem:

\begin{lstlisting}[caption={Zadefinování barev}, label={lst:ComposeCode}, language=Kotlin]
  val md_theme_light_primary = Color(0xFFBC004C)
  val md_theme_light_onPrimary = Color(0xFFFFFFFF)
  val md_theme_light_primaryContainer = Color(0xFFFFD9DE)
  val md_theme_light_onPrimaryContainer = Color(0xFF400015)
  ...

  val md_theme_dark_primary = Color(0xFFFFB2BE)
  val md_theme_dark_onPrimary = Color(0xFF660026)
  val md_theme_dark_primaryContainer = Color(0xFF900039)
  val md_theme_dark_onPrimaryContainer = Color(0xFFFFD9DE)
  ...
\end{lstlisting}

Takto zadefinované barvy je následně možné použít napříč aplikací k obarvení tlačítek, textů, ploch atd.

Mimojiné jsou taktéž použity pro definování barevných motivů, které se definují následujícím způsobem:

\begin{lstlisting}[caption={Definice barevných motivů}, label={lst:ComposeCode}, language=Kotlin]
  private val LightColors = lightColorScheme(
    primary = md_theme_light_primary,
    onPrimary = md_theme_light_onPrimary,
    primaryContainer = md_theme_light_primaryContainer,
    onPrimaryContainer = md_theme_light_onPrimaryContainer,
    secondary = md_theme_light_secondary,
    ...
  )

  private val DarkColors = darkColorScheme(
    primary = md_theme_dark_primary,
    onPrimary = md_theme_dark_onPrimary,
    primaryContainer = md_theme_dark_primaryContainer,
    ...
  )
\end{lstlisting}

Díky takto zadefinovaným motivům je následně možné obarvit veškeré komponenty aplikace podle aktuálně použivaného režimu.

\begin{lstlisting}[caption={Definice barevných motivů}, label={lst:colorsDef}, language=Kotlin]
  @Composable
  fun AppTheme(
    useDarkTheme: Boolean = isSystemInDarkTheme(),
    content: @Composable() () -> Unit
  ) {
    val colors = if (!useDarkTheme) {
      LightColors
    } else {
      DarkColors
    }
  
    MaterialTheme(
      colorScheme = colors,
      content = content
    )
  }
\end{lstlisting}

\subsubsection{Typografie}
je používána k definování stylu písma. Využívá k tomu styly definované Material designem. ten definuje celkem 15 stylů písma,
kde každé z nich má definovaný způsob použití. \cite{material3} Jelikož se jedná o výchozí styly písma, tak lze k těmto stylům přistupovat přes
Composable funkci \code{MaterialTheme} popsanou v kódu \ref{lst:colorsDef} aniž by se parametr \code{typography} musel explicitně
uvádět.

\begin{lstlisting}[caption={Ukázka použití stylu písma}, label={lst:typographyExample}, language=Kotlin]
  Text(
    text = news.title,
    style = MaterialTheme.typography.headlineMedium
  )
\end{lstlisting}

\section{Použité technologie}
Následující podkapitola je věnována konkrétním technologiím, které byli pro tvorku komponent z předchozí kapitoli použity.

\subsection{Kotlin}
\subsection{Coroutines}
\subsection{Ktor}
Ktor je open-source framework vytvořený společností JetBrains pro tvorbu aplikací jak na serverové tak i klientské části pomocí programovacího 
jazyka Kotlin.

Ktor byl vyžit především kvůli tomu, že obsahuje multiplatformního asynchronního HTTP klienta pomocí kterého je možné zadávat HTTP požadavky a 
zpracovávat odpovědi. 

\begin{lstlisting}[caption={Definice barevných motivů}, label={lst:colorsDef}, language=Kotlin]
  private val client = HttpClient {
    install(HttpTimeout) {
        requestTimeoutMillis = 40000
    }
}

suspend fun getEventsXml(): EventsXmlDto {
    val response: String = client.get("https://kalendar.pribram.eu/...").body()
    return format.decodeFromString<EventsXmlDto>(response.cleanUpEventXml())
}
\end{lstlisting}

\subsection{Voyager}
Voyager je multiplatformní navigační knihovna, která umožňuje navigovat mezi různými obrazovkami a destinacemi v multiplatformních mobilních
 aplikacích. \cite{voyager} Jeho hlavním cílem je poskytnout jednotné rozhraní pro navigaci v různých mobilních platformách, jako jsou Android a iOS, a 
 zároveň maximalizovat sdílený kód a snižovat duplikaci kódu.

 V rámci implementované aplikace byla Voyager navigace použita k implementaci základní navigace mezi jedlotlivými obrazovkami.
 Příkladem takové navigace jsou veškeré možné přechody v rámci domovské obrazovky. Tato navigace vyžívá ke své funkci takzvané 
 \textit{Stack API}, které jehož implementace fungguje na principu zásobníku. S tím, že pokud uživatel vstoupi na navou obrázovku 
 (například přejde na stranku zobrazující detail vybrané udásloti), tak je do tohoto zásobníku přidán odkaz na takzvaný SnapshotState,
 který uchává stav právě opuštěné obrazovky a je znovu obnoven v případě, že se uživatel na tuto obrazovku znovu vrátí. Zároveň tento
 zásobník slouží k tomu, aby navigace vždy věděla na jakou stránku se má vrátit (poslední v zásobníku), když uživatel provede akci zpět
 například pomocí tlačítka zpět na platformě Android. \textit{Stack API} zároveň umožnuje použití několika funkcí jako jsou například 
 \code{push}, \code{replace}, \code{replaceAll} používané pro průchod vpřed nebo funkce \code{pop}, \code{popAll}, \code{popUntil}
  pro zpětný návrat. 

 Díky této implementaci je možné používané obrazovky do sebe libovolně zanořovat a v případě, že je potřeba nějakým způsobem upravit
 stav předchozích TODO

 Nicméně tento způsob navigace není vhodné použít pro navigaci mezi jednotlivými záložkami aplikace (lišta ve spodní části displaye) 
 a proto je tado část navigace 
 implementována pomocí takzvané \textit{Tab navigation}, kterou knihovna Voyager, taktéž poskytuje. V přípaně použití záložek se
 průchod nezapisuje do zásobníku jako v předchozím případě jelikož jednotlivé záložky jsou na stejné urovní a implementace navigace
 založené na zásobníku by byla pro uživatele matoucí.

 TODO
 \begin{lstlisting}[caption={Ukázka použití navigace založené na záložkách}, label={lst:tabNav}, language=Kotlin]
TabNavigator(
  tab = HomeTab
) {
    Scaffold(
        modifier = Modifier.fillMaxSize(),
        bottomBar = {
            BottomNavigation(
                backgroundColor = MaterialTheme.colorScheme.background
            ) {
                TabNavigationItem(HomeTab)
                TabNavigationItem(EventsTab)
                TabNavigationItem(ParkingTab)
                TabNavigationItem(MoreTab)
            }
        },
        content = { CurrentTab() },
    )
}
\end{lstlisting}

\subsection{Koin}
Koin je moderní knihovna pro správu závislostí v aplikacích napsaných v jazyce Kotlin. Jedná se o lehkou a snadno použitelnou alternativu 
k jiným známým knihovnám, jako je například Dagger. Koin se zaměřuje na jednoduchost použití a minimalismus, což usnadňuje vývoj aplikací 
a zároveň zlepšuje čitelnost a údržbu kódu.

Hlavním principem Koinu je deklarativní přístup k definici závislostí pomocí tzv. modulů. V modulu se specifikují všechny závislosti a 
jejich vytváření, a to pomocí jednoduchých funkcí nebo tzv. singletons. Tento přístup umožňuje snadnou konfiguraci závislostí a poskytuje
 vývojářům transparentní pohled na strukturu aplikace.

\bigskip

V rámci této aplikace byl Koin použit například pro vložení databázového ovladače za pomocí expect actual deklarace \ref{expectActual}.
Využití tohoto zápisu bylo vhodné použít především díky tomu, že převážná většitna databázové logiky je napsána v rámci sdílené 
logiky a v rámci nativní logiky, byl tak implementovám pouze databázový ovladač.

\begin{lstlisting}[caption={DI databázového ovladače pomocí Koinu}, label={lst:KoinInit}, language=Kotlin]
class MainActivity : ComponentActivity() {

  private val dbDriverFactoryModule = module {
      single { DatabaseDriverFactory(applicationContext) }
  }

  init {
      loadKoinModules(dbDriverFactoryModule)
  }
  ...
}
\end{lstlisting}

\subsection{SQLDelight}
SQLDelight je multiplatformní knihovna pro práci s relačními databázemi v aplikacích napsaných v jazyce Kotlin. Jedná se o moderní nástroj, 
který umožňuje vytváření a správu SQL dotazů pomocí typově bezpečných prostředků poskytovaných jazykem Kotlin.

Hlavní funkcionalitou SQLDelightu je automatická generace Kotlinových tříd na základě definovaných SQL schémat. To znamená, že vývojáři
 mohou psát SQL dotazy pomocí standardní SQL syntaxe a SQLDelight se postará o vygenerování příslušných tříd v jazyce Kotlin, které umožňují 
 snadný a bezpečný přístup k databázi. Jediným rozdílem oproti standardním SQL dotazům je označení jednotlivých SQL dotazů takzvaným 
 štítkem (viz "selectAllNews:" ve výpisu kódu \ref{SQLDotaz}) pomocí kterého je vygenerována příslušná Kotlin funkce. 

\begin{lstlisting}[caption={SQL dotaz}, label={lst:SQLDotaz}, language=SQL]
selectNewsById:
SELECT *
FROM News
WHERE id = :id;
\end{lstlisting}

Vygenerové metody (dotazy) lze následně nalézt ve složce \code{} a pro výše uvedený dotaz vypadá takto

\begin{lstlisting}[caption={SQL vygenerovaný dotaz}, label={lst:SQLGeneratedDotaz}, language=SQL]
private inner class SelectNewsByIdQuery<out T : Any>(
  public val id: Long,
  mapper: (SqlCursor) -> T,
) : Query<T>(mapper) {
    override fun addListener(listener: Query.Listener) {
    driver.addListener("News", listener = listener)
  } TODO
  \end{lstlisting}
  

SQLDelight také nabízí silnou typovou kontrolu při práci s daty v databázi. To znamená, že chyby v SQL dotazech jsou odhaleny již při
 kompilaci kódu, což usnadňuje odhalování chyb a zvyšuje stabilitu aplikace.

I přesto, že většina kódu může být psána v balíčku sdílenem mezi všemi platformami, je zde i část z předchozí ukázky \ref{lst:SQLGeneratedDotaz}
, kterou je potřeba naimplementovat nativně. Konkrétně se jedná o ovladače k jejichž implementaci jsou potřeba nativní knihovny a musí
být proto implementovány v balíčcích jednotlivých platforem. Pro 

TODO
\begin{lstlisting}[caption={SQL vygenerovaný dotaz}, label={lst:SQLGeneratedDotaz}, language=SQL]
  actual class DatabaseDriverFactory {
    actual fun createDriver(): SqlDriver {
        //val driver: SqlDriver = JdbcSqliteDriver("jdbc:sqlite:test.db")
        val driver: SqlDriver = JdbcSqliteDriver(JdbcSqliteDriver.IN_MEMORY)
        AppDatabase.Schema.create(driver)
        return driver
    }
}
\end{lstlisting}


\subsection{Full text search impl tech} \label{fulltextSearch}
TODO
 neco na fulltextové vyhledavani


\subsection{Coil}
Coil je knihovna pro načítání a zobrazování obrázků v aplikacích pro Android, napsaná v jazyce Kotlin. Jedná se o moderní a jednoduché 
řešení pro práci s obrázky, které nabízí rychlost, efektivitu a snadnou integraci. Knihovna poskytuje jednoduché API pro načítání obrázků 
z různých zdrojů, včetně URL adres, souborů a zdrojů z paměti. Díky tomu je integrace obrázků do aplikace snadná a přizpůsobitelná potřebám projektu.

Coil nabízí automatické dohledávání velikosti obrázků na základě rozměrů zobrazení, což pomáhá optimalizovat paměť a výkon aplikace. Tato funkce 
umožňuje načítat obrázky ve správné velikosti a snižuje zátěž na síťové spojení. Knihovna podporuje širokou škálu formátů obrázků, včetně PNG, 
JPEG, GIF, SVG a WebP, což umožňuje pracovat s různými typy obrázků bez nutnosti dalšího přizpůsobování.

Další výhodou Coil je možnost efektivního cachování obrázků, což pomáhá snižovat čas načítání a zlepšuje uživatelský zážitek. Knihovna je navržena tak, 
aby se snadno integrovala s moderními architekturami aplikací, jako je například Android Jetpack a architektura MVVM. To umožňuje vývojářům využívat 
přednosti moderních technologií a frameworků při práci s obrázky.

TODO uvest coil
\begin{lstlisting}[caption={Coil}, label={lst:Coil3}, language=SQL]
  AsyncImage(
    model = news.thumbnailUri,
    contentDescription = "Sample",
    contentScale = ContentScale.Crop,

    modifier = Modifier.aspectRatio(4f / 3f)
  )
\end{lstlisting}

\section{Implemtace UI vrstvy} \label{UILayerImpl}
V rámci této kapitoly budou ukázáno jakým způsobem byla implementována UI vrstva navržená v kapitole \ref{UILayerNavrh}, j

\subsection{Implementace ViewModelů} \label{ViewModelImpl}
TODO % odkaz na UI Layer
V rámci implementované aplikace byl pro každou obrzovku implementovám jeden ViewModel, který se stará o logiku každé obrazovky zvlášť.


\subsection{Implementace stavu aplikace} \label{stateHandlingImpl}
Tato kapitola slouží k příblížení toho jak takzvaný \textit{UI State}, kterému byl věnován paragraf \textit{UI state} v 
kapitole \textit{Vrstvy architektury \ref{vrstvyArchitekturySection} } je implemementován v rámci ukázkové aplikace.

Z pohledu UI se jedná o důležitou část aplikace o jejíž aktualizaci se stará již zmíněný ViewModel \ref{} neboli ScreenModel v rámci
implementované aplikace. 
Pro zachování stavu jednotlivých obrazek byla použita datová třída, která v sobě umožnujě uchovávat veškeré možné stavy dané obrazovky.
Pro ukázku toho jak byla taková datová třída implementována byla vybrána obrazovka událostí, která v rámci aplikace potřebuje 
uchovávat největsí množství informací (viz \ref{lst:EventState})

\begin{lstlisting}[caption={Event State katalog}, label={lst:EventState}, language=Kotlin]
data class EventsState(
  val timeFilteredEvents: List<Event> = emptyList(),
  val events: StateFlow<List<Event>> = MutableStateFlow(emptyList()),
  val selectedDateStart: LocalDateTime = LocalDateTime(
      Clock.System.todayIn(TimeZone.currentSystemDefault()),  TODO replace by current impl
      LocalTime(0, 0)
  ),
  val selectedDateEnd: LocalDateTime = LocalDateTime(
      Clock.System.todayIn(TimeZone.currentSystemDefault()),
      LocalTime(23, 59)
  ),
  val selectedFilterOption: FilterOption = FilterOption.TODAY,
  val isDatePickerOpen: Boolean = false,
  val filteredEventsCategories: List<EventCategory> = emptyList(),
  val isFetchingEvents: Boolean = false,
)
\end{lstlisting}

Takto zadefinované stavy mohou být v aplikaci použity například následujícím způsobem. Kde stav udržován 

\begin{lstlisting}[caption={Použití stavu v aplikaci}, label={lst:StateImpl}, language=Kotlin]
  val screenModel = getScreenModel<HomeScreenModel>()
  val state by screenModel.state.collectAsState()

  val news = state.news.collectAsState()
  LazyColumn {
      items(news.value) { news ->
          NewsItem(news = news, onItemClick = {
              navigator.push(NewsDetailScreen(news))
          })
      }
  }
\end{lstlisting}

\subsection{Implementace událostí aplikace} \label{eventHandlingImpl}


\section{Tvorba UI obrazovek}
TODO %obecne ukazat jak se UI v compose tvori ze je to daklarativne

Jak již bylo zmíněno v kapitole \textit{Architektura frameworku Compose Multiplatfom \ref{ComposeArch}}, tak k tvorbě UI se v Compose Multiplatform používají 
takzvané Composable funkce, které představují jednotlivé UI prvky zobrazované na obrazovce koncového zařízení. 

Tyto Composable funkce tak mohou představovat jednotlivá tlačítka, texty vstupní pole, seznamy, ale také celé soubory těchto prvků jako jsou 
například celé obrazovky.

Na následujícím výpisu kódu \ref{lst:ConsumeUIState} je proto ukázáno jak mohou být do sebe jednotlivé Composable funkce zanořeny a tím tvoří
takzvaný sémantický strom taktéž popsaný v kapitole \textit{Architektura frameworku Compose Multiplatfom \ref{ComposeArch}}

\begin{lstlisting}[caption={Popis UI widgetů pomocí jazyka Kotlin}, label={lst:ConsumeUIState}, language=Kotlin]
  @Composable
  fun LatestNewsScreen(
      viewModel: NewsViewModel = viewModel()
  ) {
      // Show UI elements based on the viewModel.uiState
  }
\end{lstlisting}

%Zároveň 

%Z těchto Composable funkcí se skládá celé UI


Obsahem následujících podkapitol bude ukázka UI komponent, které byly použity k implementaci navrženého UI.

\subsection{Domovská obrazovka}
Uživatelké rozhraní domovské obrazovky je kompletně implemetováno pomocí Compose Multiplatform a nebylo při jeho implemementaci potřeba
přistoupit k nativímu řešení ani na platformě iOS nebo desktop. 

K tvorbě UI domovské obrazovky bylo nejprve přistupováno na základě vytvořených wireframes a následně stylizováno tak, aby 
jednotlivé komponenty odpovídali navržené podobě UI z kapitoly \ref{navrhMockupModelu}

LAZY ROW LAZY COLLUMN , OBRAZKY POMOCI COIL, STYLOVANI POMOCI DESIGN SYTEMU, VYUZITI DATABAZE, ukazka Event lazy row komoponenty

Obě tyto komponent navíc nabízí postupné načítání jejich obsahu, což nezpomaluje načítání obsahu v případně většího množství novinek
nebo událostí.

\begin{lstlisting}[caption={Coil}, label={lst:Coil3}, language=Kotlin]
  @Composable
  fun EventLazyRow(category: EventCategory, state: EventsState) {
      val scrollState = rememberLazyListState()
      val coroutineScope = rememberCoroutineScope()
      val navigator: Navigator = LocalNavigator.currentOrThrow
  
      Column {
          Text( ... )
          LazyRow( ... ) 
      {  
        items(eventList) { event ->  //state.filteredEvents
            EventItem(event = event, onItemClick = {
              navigator.push(EventDetailScreen(event))
            })
          }
        }
      }
  }
\end{lstlisting}

\subsection{Obrazovka \textit{Události}}

V rámci obrazovky "Události" je používána stejná komponanta pro zobrazování událostí jako byla použita na domovská obrazovce. 

pro zobrazené údálostí "EventLazyRow". 

LAZY ROW , DATE PICKER, SPECIAL CHIPS


\subsection{Obrazovka \textit{Parkování}} \label{parkingScreenImpl}
K implementaci mapových podkladů bylo zapotřebí použít nativího řešení. 


Bylo využito UI komponenty \code{GoogleMap} z \code{com.google.maps.android.compose}, která umpožňuje vložení mapových podkladů 
na platdformě Android.

Dále byla tato obrazovka rozšířena o vyhladvací bar, který uživateli dává možnost jednoduchého vyhledání parkovací zóny podle názvu nebo čísla 
parkovací zóny.

K tomu je použito fulltextové vyhledání ... popsané v kapitole \ref{fulltextSearch}. 


Dále zde byl umplentován bottom sheet který je zobrazen pouze v případě, že uživatel vyberere pro o jakém parkovaním místě chce zobrazit
podrobné informace. Nezmenšuje tak uživateli prostor pro rychlé vyhlání parkovanící zóny.



\section{Řešení problémů spojených s multiplatformním vývojem}
Nedostatek knihoven
Mezi jeden z hlavních problému patří nedostatek vhodných multiplatformních knihoven a ten se projevil i v případě implementace mapových podkladů
do aplikace kde byla nakonec zvolena implementace nativních mapových podkladů za použití expect a actual deklarací (viz paragraf \ref{expectActual}).

Preview
Další problémem bylo nefunkční náhled UI , což se na výsledném UI nikterak neprojevilo, ale celý proces tvorby UI to značně prodloužilo.

Špatná nebo téměř žádna dokumentace k knihovnám třetích stran a v případě co se týče Compose Multiplatfrom, tak zde je téměř kompletně spoléháno na
identic. 
Na druhou stranu Compose Multiplatform ještě není na všech platformách ve stabilní verzi a proto je možné, že po vydání stabilních verzí i pro jiné
platformy se dokumentace od JetBrains rozříší.


\subsection{Implementace mapových podkladů}

Jak jž bylo zmíněno v kapitole \ref{parkingScreenImpl} tak implementace matových podkladů byla implementována pomocí 

\begin{lstlisting}[caption={Coil}, label={lst:Coil3}, language=SQL]
  GoogleMap(
    modifier = Modifier.fillMaxSize(),
    properties = MapProperties(
        isTrafficEnabled = true,
        mapType = MapType.NORMAL,
        mapStyleOptions = MapStyleOptions(MapStyle.JSON_LIGHT)
        /*latLngBoundsForCameraTarget = LatLngBounds(
            LatLng(49.7195186,13.9845228)) */
    ),
    cameraPositionState = cameraPositionState
) {...}
\end{lstlisting}

\myparagraph{impementace map theme}

\myparagraph{impementace map polygons}






\chapter{Testování} \label{testsSection}
Tato kapitola se bude věnovat předvším UI teestování a to z nějkolika růzých pohledů. 

\section{Testování UI}
Od verze 1.6.0 Compse multiplatform umožnuje testování UI na všech platformách. \cite{composeNews1.6.0}

UI testy se používají k ověření, že uživatelské rozhraní aplikace funguje podle očekávání. To zahrnuje testování prvků uživatelského rozhraní, uživatelských 
interakcí a navigačních toků, aby se zajistilo plynulé uživatelské prostředí.

Mezi základní typy UI testl se řadí UI testy testující ktitické uživatelské interakce na jedné obrazovce a dále například navigační testy testující
správnost fungování navigace v dané aplikaci.


\section{Testování výkonu}


\section{Testování kompatibility}
estování aplikace na různých zařízeních s různými velikostmi obrazovek, rozlišeními a hardwarovými konfiguracemi, aby se zajistilo, že funguje 
správně na široké škále zařízení.




\section{Možnosti testování UI v Compose Multiplatform}
Testování aplikací založených na frameworku Compose Multiplatform je stejně tak jako tvorba samotného UI založena na Jetpack Compose a využívá 
proto i stejných konceptů. Mezi tyty klíčové koncepty testovaní UI se řadí následující:


\myparagraph{Testování sémantiky}
V rámci testování
\myparagraph{API rozhraní}
Compose Multiplatform z toto důvodů taktéž využívá tři hlavní principy jak testovat UI, které se v Jetpack compose
označují jako \textit{Finders}, \textit{Assertions} a \textit{Actions}. 
K tomu aby bylo možné UI komponenty testovat se používají funkce, které tyto komponenty na obrazovce detekují a následně další funkce které nad nalezenýcmi 
komponenty umožňují provest akce podobné těm, které provádí uživatel. Pro kontrolu správnosti provední těchto akcí se používají takzvané tvrzení 
(Assertions), které ověří zdali určité UI prvky mají požadované atributy.

\textit{Finders} umožnují najít uzel nebo uzly ve strom UI struktuře pomocí tagů, vnořených textů, různých popisků a nebo pomocí \textit{Matchers}.


Pomocí \textit{Assertions}

A pomocí \textit{Actions} je možné simulovat uživatelské integrace jako jsou kliknutí nebo jiná gesta. \cite{composeTesting}

\myparagraph{Testování synchoronizace}
\myparagraph{Testování interoperability}

\begin{lstlisting}[caption={Integrace testů Gradle}, label={lst:testsIntegration}, language=Kotlin]
kotlin {
  //...
  sourceSets {
    val desktopTest by getting

    // Adds common test dependencies
    commonTest.dependencies {
      implementation(kotlin("test"))

        @OptIn(org.jetbrains.compose.ExperimentalComposeLibrary::class)
        implementation(compose.uiTest)
    }

    // Adds the desktop test dependency
    desktopTest.dependencies {
        implementation(compose.desktop.currentOs)
    }
  }
}
\end{lstlisting}
\section{Testovací případy}
Testovací případ je sada kroků nebo akcí, které jsou prováděny při testování softwarového produktu s cílem ověřit, zda se chová podle očekávání a splňuje 
požadavky. Každý testovací případ obvykle obsahuje následující prvky:

\begin{itemize}
  \item Popis: Stručný popis toho, co testovací případ testuje a jaké jsou očekávané výsledky.
  \item Předpoklady: Podmínky, které musí být splněny nebo konfigurace, která musí být provedena před spuštěním testu.
  \item Kroky: Konkrétní kroky, které musí být provedeny k provedení testu.
  \item Očekávané výsledky: Popis očekávaných výsledků testu po dokončení kroků.
  \item Aktuální výsledky: Skutečné výsledky testu, které jsou porovnány s očekávanými výsledky k určení úspěšnosti testu.
\end{itemize}

Na základě této struktury bylu sepsány následující testovací případy:


\myparagraph{Testovací případ 1: Zobrazení aktuálních novinek}

\begin{enumerate}
  \item Kroky:
    \begin{enumerate}
      \item Navigace na stránku zobrazující aktuální novinky.
      \item Ověření, že systém zobrazil seznam aktuálních novinek.
      \item Kliknutí na konkrétní novinku.
      \item Ověření, že systém zobrazil detaily vybrané novinky.
    \end{enumerate}
  \item Očekávaný výstup:
    \begin{itemize}
      \item Seznam aktuálních novinek je zobrazen.
      \item Po kliknutí na konkrétní novinku jsou zobrazeny její detaily.
    \end{itemize}
\end{enumerate}

\myparagraph{Testovací případ 2: Zobrazení aktuálních událostí}

\begin{enumerate}
  \item Kroky:
    \begin{enumerate}
      \item Navigace na stránku zobrazující aktuální události.
      \item Ověření, že systém zobrazil seznam aktuálních událostí.
      \item Kliknutí na konkrétní událost.
      \item Ověření, že systém zobrazil detaily vybrané události.
    \end{enumerate}
  \item Očekávaný výstup:
    \begin{itemize}
      \item Seznam aktuálních událostí je zobrazen.
      \item Po kliknutí na konkrétní událost jsou zobrazeny její detaily.
    \end{itemize}
\end{enumerate}

\myparagraph{Testovací případ 3: Filtrování zobrazených událostí podle data}

\begin{enumerate}
  \item Kroky:
    \begin{enumerate}
      \item Navigace na stránku zobrazující události.
      \item Ověření, že systém zobrazil seznam událostí.
      \item Zvolení konkrétního data pro filtrování událostí.
      \item Ověření, že systém zobrazil události pouze pro vybrané datum.
    \end{enumerate}
  \item Očekávaný výstup:
    \begin{itemize}
      \item Seznam událostí je filtrován podle zvoleného data.
      \item Události jsou rozděleny do kategorií podle typu události.
    \end{itemize}
\end{enumerate}

\section{Implementace testů}


\myparagraph{Testy jednotlivých UI komponent}

\begin{lstlisting}[caption={Implementace UI testu}, label={lst:testImplementation}, language=Kotlin]
  class ExampleTest {

  @OptIn(ExperimentalTestApi::class)
  @Test
  fun myTest() = runComposeUiTest {
      // Declares a mock UI to demonstrate API calls
      //
      // Replace with your own declarations to test the code of your project
      setContent {

          var text by remember { mutableStateOf("Hello") }
          Text(
              text = text,
              modifier = Modifier.testTag("text")
          )
          Button(
              onClick = { text = "Compose" },
              modifier = Modifier.testTag("button")
          ) {
              Text("Click me")
          }
      }

      // Tests the declared UI with assertions and actions of the Compose Multiplatform testing API
      onNodeWithTag("text").assertTextEquals("Hello")
      onNodeWithTag("button").performClick()
      onNodeWithTag("text").assertTextEquals("Compose")
  }
}
\end{lstlisting}

\myparagraph{End-to-end testy}


\section{Zhodnocení výsledků testování}

\section{Zhodnocení použitelnosti}

android already in production with hell a lot of features now If you want to share code among these and have single code base, going with flutter is bad idea .. Since its take nativity out. So hence you want both the teams to have a common business logic and networking thing then KMM is the way to go 

\chapter{Závěr}

\section{Evaluace vlastností Compose Multiplatform ve srovnání s cíli práce}
Vetšinu cílů, které byly stanoveny v zadání bylo možné pomocí multiplatformího frameworku Compose Multiplatform splnit a nebylo tak
nutné přistupovat na kompromisy. Veškeré implem

Nicméně při implementacni náročnějších částech aplikace bylo již občas nutné přistoupit k použití nativních řešení a tím pádem tyto dva přístupy zkombinovat.
Ve výsledku z poheledu UI, tak tato kombinace nevedla k zádným ústupkům
Nicméně díký vhodně navrženým principům jako je Expect a actual deklarace (viz paragraf \ref{expectActual}) nebylo skombinování těchto odlišných částí nikterak
implementačně komplikované a ne výsledku ani nepřehledné. 

Fakt že v některých případech bylo nutné přistoupit k nativnímu řešení nemusí být brán jakožto nevýhoda Compose Multiplatform oproti ostatním frameworkům.
Na druhou stranu lze tatu možnost vnimat i jako výhodu, kterou ostatní frameworky neposkytují a dělá takz compose Multiplatform z tohoto pohledu flexibilnější
framework.

prostor o rozříšení ostatních naticvních knihoven o mmmultipatformní API. 

Čehož výsledky by v ideáním případě bylo na daném vývojáří zdali zvolí nativní či multipaltformí cetu vývoje. 

\section{Zkušenosti z implementace na reálné aplikaci}
Preview
Nedostatek knihoven
Špatná nebo téměř žádna dokumentace k knihovnám třetích stran a v případě co se týče Compose Multiplatfrom
\section{Závěr o použitelnosti frameworku}

% kapitola main pains
% https://blog.jetbrains.com/kotlin/2021/01/results-of-the-first-kotlin-multiplatform-survey/


\section{Shrnutí dosažených výsledků}
\section{Zhodnocení splnění cílů práce}
\section{Návrhy pro budoucí vývoj a výzkum}
Z pohledu aplikace jsou zde velké možnosti pro budoudcí vývoj nizcméně 


Časem se zajisté ukáží

\bigskip

mohou ukázat další možnosti využití tohoto frameworku na jiných platformách


