% Do not forget to include Introduction
%---------------------------------------------------------------
\chapter{Úvod}
% uncomment the following line to create an unnumbered chapter
%\chapter*{Úvod}\addcontentsline{toc}{chapter}{Introduction}\markboth{Introduction}{Introduction}
%---------------------------------------------------------------
\setcounter{page}{1}

% The following environment can be used as a mini-introduction for a chapter. Use that any way it pleases you (or comment it out). It can contain, for instance, a summary of the chapter. Or, there can be a quotation.
%\begin{chapterabstract}
%	\lipsum[1]
%\end{chapterabstract}

%\section{Motivace}
\section{Cíle práce} \label{goals}
Prvním důležitým cílem práce je analyzovat použitelnost nově nastupující technologie na poli vývoje multiplatformního UI a otestovat, jaké
nové principy přináší. Dále tuto technologii porovnat s ostatními frameworky pro tvorbu multiplatformního UI a pokusit se
rozebrat důležité principy, na kterých jsou tyto technologie postaveny. 

Další podstatným cílem je vytvoření aplikace, která tuto technologii implementuje a zaměření se při tom na slabé stránky, 
které aktuálně multiplatformní UI provází.

Posledním hlavním cílem je vytvořenou aplikaci otestovat a zhodnotit použitelnost daného frameworku v praxi.

\section{Stručný přehled obsahu práce}
V úvodu se práce zabývá otázkou co to vlastně multiplatformní vývoj je, proč se jím zabývat a jakých zařízení se může týkat.
Dále je probrána otázka v jakých případech se vyplatí aplikovat multiplatformní UI a na jakých zařízeních. 

%a porovnání vazby s UI s logikou daného aplikace vůči multipaltfomovodsti.



%kdy multiplatformí vývoj nemá smysl (vyfocení závady)


Jaké jsou výhody a nevýhody multiplatformních aplikací  v porovnaní s nativními aplikacemi.

Existujícími frameworky a jich porovnáním s Compose Multiplatform.

Detailně rozebrána architektura Compose Multiplatform jak framework funguje a jaké další technologie jsou potřeba k smysluplné implementaci tohoto
frameworku.

Dále je se práce zabývá návrhem a následnou tvorbou multiplatformního UI pomocí frameworku Compose Multiplatform.

V v jedné z posledních části se týká možností testování takto vytvořeného UI a následného testování UI na naimplementované aplikaci.

je věnován shrnutí celého procesu implementace a vyzdvižení naskytlých problémů a výhod oproti nativnímu případně jiným multiplatformním frameworkům



Obecně něco o multiplatformním vývoji.

\section{Definice multiplatformního vývoje UI}

Technologie sloužících k tvorbě multiplatformních UI umožňují vývojářům vytvářet jednotná uživatelská rozhraní, 
která mohou být nasazena na různá zařízení jako jsou mobilní zařízení, tablety, televize, hodinky, obrazovky aut či 
klasické počítače a to buďto v podobě desktopové nebo webové aplikace. Cílem multiplatformního vývoje je tak dosáhnout jednotného 
uživatelského zážitku bez nutnosti psát a udržovat oddělené kódy pro každou platformu. Nicméně jak je vidno z předchozího výčtu zařízení, 
tak ne vždy má smysl multiplatformní přístup aplikovat a tomu kdy je vhodné aplikovat multiplatformní vývoj je věnována následující kapitola.  

\section{Uplatnění multiplatformního vývoje a sdíleného UI}
Aktuálně největší uplatnění multiplatformního UI nabízí mobilní vývoj, kde je díky multiplatformním frameworkům možné vyvíjet
aplikace pro platformy Android a iOS současně. Je tomu tak z důvodu, že mobilní vývoj je aktuálně jeden TODO také díky podobnostem majících na návrh multiplatformního 
UI vliv jako je například velikost obrazovky.

I přesto, že multiplatformní frameworky umožňují implementaci multiplatformním UI na většinu nejvíce používaných platforem jako je Android, iOS,
Android TV, tvOS, Wear OS, watchOS nebo Android Automotive, tak né vždy je vhodné těchto možností využít. Z pohledu UI mají ty platformy často jiné 
velikosti obrazovek, jiné možnosti ovládaní a proto, je často multiplatformní UI a často i veškerá logika implementována konkrétně pro danou platformu
nebo typ zařízení. Je proto vždy nutné vědět jaký typ aplikace bude z pohledu aplikační logiky implementován, jaké budou jeho způsoby užití a na jakých 
platformách bude daná aplikace implementována.

Obecně lze tedy říci, že efektivita implementace multiplatformních aplikaci se může dle těchto omezeních a požadavků výrazně lišit.

%I přesto, že tato práce je věnována především tvorbě UI, tak nesmí být opomenuta aplikační logika, které se za ním skrývá a má UI podstatný vliv.
% Dále zde hrají velkou roli případy užití, které mají na jednotlivá a UI vliv a při multiplatformním vývoji je třeba dbát na jelikož né každá 
% aplikace je z tohoto pohledu vhodná pro multiplatformní

\section{Důvody multiplatformního vývoje a sdíleného UI}

Mezi primární důvody vedoucí firmy a jednotlivce k vývoji multiplatformních aplikací patří především
snížení nákladů na vývoj a následně také na údržbu. Jednodušší dosažení konzistentního vzhledu
na různých platformách nebo například možnost znovu používat komponenty UI na různých platformách.

Mezi další důvody může například patřit možnost rychlejších aktualizací, jelikož nové funkce mohou být 
implementovány jednotně a rychle na všech platformách. 

\chapter{Analýza}
Tato kapitola je zaměřena na představení aktuálně používaných multiplatformních frameworků a porovnání těchto frameworků
s technologií Compose Multiplatform. Shrnuje jejich podstatné rysy a následně slouží k
jednoduššímu porovnání a vyhodnocení použitelnosti frameworku Compose Multiplatform. Zároveň je v této kapitole detailněji
rozebrán samotný Compose Multiplatform a jak z pohledu implementace uživatelského rozhraní, tak i z pohledu implementace
aplikační logiky, ke které využívá technologii Kotlin Multiplatform.

Po dokončení analýzy obou těchto technologií se práce věnuje porovnáním všech těchto frameworků jednak z pohledu architektury
a náročnosti implementace, tak z pohledu výkonu aplikací implementovaných pomocí těchto technologií. 

Konec této kapitoly je věnován limitacím frameworku Compose Multiplatform oproti nativním řešením, které přímo vyplývají 
z provedené analýzy.  


\section{Přehled existujících frameworků}
Mezi aktuálně nejpopulárnější multiplatformní frameworky jednoznačně patří Flutter a React Native. \cite{crossPlatformFrameworksStats}
V následujících kapitolách jsou proto tyto nejpoužívanější frameworky podrobně porovnány s frameworkem Compose Multiplatform a u každého z nich 
jsou vybrány důležité vlastnosti, které jsou pro tyto frameworky typické. 

Jednotlivé frameworky jsou seřazeny postupně od nejstaršího
po nejmladší, což umožňuje lepší náhled na to, jak se jednotlivé frameworky vyvíjely v čase. Pro lepší ilustraci rozdílů 
mezi jednotlivými frameworky byla zvolena 
podobná struktura jednotlivých kapitol, čehož bylo možné docílit díky mnoha společnými rysům napříč frameworky.

%---------------------------------------------------------------
\subsection{React Native}
%---------------------------------------------------------------
React Native byl jedním z prvních frameworků pro tvorbu multiplatformního UI a do jisté míry ovlivnil i ostatní popisované
frameworky. Jeho vývoj započal ve společnosti Facebook během interního hackaton projektu a první jeho oficiálně publikovaná
verze vyšla začátkem roku 2015. \cite{reactNativeHistory}
Nyní se jedná o open-source framework, kde jeho hlavním cílem je umožnit vývojářům vytvářet nativní mobilní aplikace 
pro platformy Android a iOS z jednoho společného kódu napsaného v jazyce JavaScript nebo TypeScript.

\section*{Klíčové vlastnosti React Native}

\myparagraph{Komponentní architektura} 
React Native využívá komponentní architekturu, která vývojářům umožňuje 
vytvářet znovupoužitelné komponenty. \cite{reactNativeComponents} Tato architektura je jednak založena na obecných
React komponentách, ale zároveň také na React Native specifických komponentách, které se dále dělí na takzvané core
komponenty, komponenty vytvořené komunitou či vlastní nativní komponenty. \cite{reactNativeComponents}

% // todo komponenty prekladane na nativni 
    
\myparagraph{Deklarativní zápis UI}
React Native stejně jako React pro webové aplikace využívá pro zápis UI deklarativní způsob, 
při kterém využívá JSX (JavaScript XML) syntaxe k popisu struktury UI komponent. \cite{reactNativeJSX}
Takto zapsané UI lépe reflektovalo aktuální stav aplikace.
Tento způsob zápisu začal na mobilních platformách růst popularitě právě díky Reactu Native, který po svém uvolnění v roce 2013 
defacto nastartoval éru deklarativního zápisu UI na mobilních platformách. \cite{declarativeUIHistory}

\myparagraph{Fast Refresh} 
Fast Refresh je v funkce, která vývojářům umožňuje okamžitě vidět výsledky provedených 
změn v kódu bez nutnosti znovu sestavení aplikace. \cite{reactNativeFastRefresh}

\myparagraph{JavaScript/TypeScript} 
Aplikační logika v React Native se píše v jazyce JavaScript nebo TypeScript, 
což usnadňuje snadnou integraci s existujícími webovými technologiemi. \cite{reactNativeFundamentals}

\myparagraph{Rozsáhlá komunita} 
React Native má rozsáhlou komunitu vývojářů, což vede k bohatému ekosystému 
třetích stran, včetně mnoha dostupných knihoven a modulů. \cite{reactNativeComunity}

\myparagraph{Expo framework} 
Pro ještě snazší start vývoje poskytuje React Native Expo framework, který 
zjednodušuje proces vývoje a umožňuje rychlé prototypování. \cite{reactNativeExpo}

\subsection*{Architektura frameworku React Native}

React native do roku 2022 využíval architekturu založenou na návrhového vzoru Bridge, který spojoval kód napsaný v JavaScriptu s nativní kódem určeným pro danou platformu. 
Tyto dva celky byly spuštěny na souběžných vláknech a komunikovaly spolu pomocí zasílání serializovaných zpráv. Časem se ale ukázalo, že se tato komunikace
a další její charakteristiky stávají úzkým hrdlem celého systému a byla proto od verze 0.68 nahrazena JavaScriptovým rozhraním zvaným JSI. \cite{reactNativeAboutNewArch}

JSI nově JavaScriptu umožňuje držet referenci na C++ objekty a volat nad nimi potřebné metody. \cite{reactNativeAboutNewArch} Toho využívá nový renderovací systém zvaný \textit{Fabric}, který 
frameworku napomáhá sjednotit renderovací logiku prováděnou v C++ a zlepšit tak interoperabilitu s nativními platformami.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth]{react-natice-xplat-implementation-diagram.png}
  \caption{React Native }
  \label{fig:react-natice-xplat-implementation-diagram}
\end{figure}

% \begin{figure}[H]
%   \centering
%   \includegraphics[width=0.55\textwidth]{react-native-data-flow.jpg}
%   \caption{React Native tok dat}
%   \label{fig:react-natice-data-flow}
% \end{figure}


% I přes tyto změny React Native stále využívá systém dvou typů vláken označovaných jako \textit{JavaScript Thread} a \textit{UI Thread} (známé taktéž pod názvem \textit{Main Thread}) 
% mezi které rozděluje práci.


Jak je vidět na obrázku \ref{fig:react-natice-xplat-implementation-diagram}, tak \textit{Fabric} de facto plní funkci prostředníka, který převádí React 
komponenty na nativní komponenty pro každou platformu. 

Pro lepší představu jak dané komponenty vypadají slouží následující ukázka kódu \ref{lst:reactNativeJSX}.

\begin{lstlisting}[caption={Popis UI komponent pomoci JSX}, label={lst:reactNativeJSX}, language=XML]
function MyComponent() {
  return (
    <View>
      <View
        style={{backgroundColor: 'red', height: 20, width: 20}}
      />
      <View
        style={{backgroundColor: 'blue', height: 20, width: 20}}
      />
    </View>
  );
}
// <MyComponent />
\end{lstlisting}

Na ukázce kódu \ref{lst:reactNativeJSX} jsou použity některé z nejpoužívanějších core komponent, které se při psaní React
Native aplikací používají. \cite{reactNativeComponents} Jak již bylo zmíněno dříve, tak tyto komponenty jsou následně převedeny 
na nativní komponenty pro každou platformu a to jakým způsobem Fabric dané komponenty převádí se dá rozdělit do následujících tří
na sebe navazujících fází: \cite{reactNativeRenderCommitMount}
 
%Na této ukázce je zároveň vidět použití deklarativního zápisu, které bude podrobněji probráno v následující kapitole.

\smallskip

\myparagraph{Render}
Během této fáze se z jednotlivých komponent (React Elementů) sestaví strom elementů v JavaScriptu (viz levá část obrázku \ref{fig:react-native-render-pipeline}) a nad tímto stromem se 
následně spustí rekurzivní redukce, při které dojde k vytvoření nového stromu takzvaného React Shadow Tree. (viz prostřední část obrázku \ref{fig:react-native-render-pipeline})
\cite{reactNativeRenderCommitMount} Ten se skládá z jednotlivých React Shadow Nodes, které reprezentují objekty v C++ a tím přechází tato renderovací fáze do další fáze zvané commit.\cite{reactNativeRenderCommitMount}

\myparagraph{Commit}
V rámci této fáze je pro každý React Shadow Node vypočítána jeho pozice a velikost na koncovém zařízení a díky tomu může renderovací systém
přejít k poslední fázi zvané Mount. \cite{reactNativeRenderCommitMount}

\myparagraph{Mount}
Během této poslední fáze dojde k transformaci \textit{React Shadow Tree} na \textit{Host View Tree} (viz pravá část obrázku \ref{fig:react-native-render-pipeline}) a to tak, že každý \textit{React Shadow Node}
se transformuje na jeho ekvivalent v nativní podobě. \cite{reactNativeRenderCommitMount} Čili například na platformě Android se $<ViewShadowNode>$ přetransformuje na android.view.ViewGroup. \cite{reactNativeRenderCommitMount}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.99\textwidth]{react-native-render-pipeline.png}
  \caption{React Native vykreslovací fáze}
  \label{fig:react-native-render-pipeline}
\end{figure}

%---------------------------------------------------------------
\subsection{Flutter}
%---------------------------------------------------------------
Flutter je open-source softwarový toolkit pro vývoj uživatelských rozhraní (UI). \cite{flutterfaq} Za vývojem stojí společnost Google a je určený k vytváření nativně kompilovaných 
aplikací pro mobilní zařízení, web a desktop z jednoho zdrojového kódu. \cite{flutterfaq}
Byl vydán v roce 2017 a získal značnou popularitu mezi vývojáři díky svému snadnému použití, flexibilitě a schopnostem tvorby UI.

\subsection*{Klíčové vlastnosti Flutteru}

\myparagraph{UI založené na widgetech} 
Flutter využívá reaktivně deklarativní UI založené na widgetech. \cite{flutterUI} Widgety jsou základními stavebními 
bloky Flutter aplikací, představující vše od strukturálních prvků po stylistické komponenty. \cite{flutterWidgets}

\myparagraph{Hot Reload} 
Další z významných funkcí Flutteru, která významně zrychluje vývojový proces a zvyšuje produktivitu je funkce "Hot Reload". 
Během vývoje běží Flutter aplikace na virtuálním počítači (Dart VM), který díky této funkci umožňuje okamžitě vidět provedené změny
v kódu bez nutnosti úplné rekompilace aplikace. \cite{flutterHotReload} Teprve pro vydání jsou Flutter aplikace kompilovány přímo do strojového kódu, 
ať už jde o instrukce Intel x64 nebo ARM, případně do JavaScriptu pokud jsou cíleny na web. \cite{flutterArchOverview}


\myparagraph{Jeden zdrojový kód pro více platforem} 
S Flutterem mohou vývojáři psát jeden zdrojový kód pro obě platformy Android a iOS, což snižuje dobu vývoje a úsilí 
vynakládané na údržbu. Flutter také rozšířil svou podporu pro cílení webových a desktopových aplikací, umožňující širší dosah s minimálními změnami kódu. \cite{flutter}

\myparagraph{Rozsáhlá sada widgetů}
Flutter poskytuje komplexní sadu přizpůsobitelných widgetů, které usnadňují vytváření složitých a vizuálně 
atraktivních uživatelských rozhraní. Tyto widgety zahrnují vše od základních tlačítek a textových polí až po 
pokročilé komponenty jako jsou grafy a animace. \cite{flutterWidgets2}

\myparagraph{Programovací jazyk Dart}
Aplikace vytvořené pomocí frameworku Flutter jsou psány v jazyce Dart, moderním objektově orientovaném programovacím jazyce 
vyvinutém společností Google. Dart je navržen pro optimální výkon a produktivitu, což ho činí vhodným pro mobilní a
webový vývoj. \cite{dart}

\myparagraph{Způsob renderovaní UI}
Na rozdíl od Reactu Native Flutter nepoužívá platformě specifické komponenty koncových zařízení, ale veškeré UI komponenty (widgety)
renderuje pomocí vlastního renderovacího enginu. \cite{flutterRenderingModel}


\subsection*{Architektura frameworku Flutter} 
Jak je vidět na obrázku \ref{fig:flutter_architectural_layers}, tak architektura Flutteru je rozdělena do tří hlavních vrstev. \cite{flutterArchOverview}
Embedder je vrstva, která umožňuje integrovat Flutter do konkrétních platforem jako je Android, iOS, desktop nebo web. 
Každý embedder obsahuje platformě specifický kód, který je potřebný pro spuštění Flutteru na dané platformě.
Engine je vrstva starající se o vykreslování grafiky, kdykoli kdy je potřeba vykreslit nový snímek. \cite{flutterArchOverview} 
Framework je vrstva, která je používána vývojáři k vytváření uživatelských rozhraní a definování chování aplikace. 
Obsahuje hotové widgety, funkce pro manipulaci s UI a další nástroje pro vývojáře. \cite{flutterArchOverview} 


\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth]{flutter_architectural_layers.png}
  \caption{Flutter architectural layers}
  \label{fig:flutter_architectural_layers}
\end{figure}

Mezi hierarchicky poslední a neméně důležitou častí tohoto frameworku jsou platformě specifické knihovny Material and Cupertino. Tyto knihovny
jsou následně využívány widgety k implementaci konkrétního design systému. Díky tomu je možné uživateli navodit nativní pocit z dané aplikace.

\medskip

Z pohledu UI je důležitým prvkem právě Flutter framework, který zároveň definuje jak spolu jednotlivé widgety interagují.

Widget je ve Flutteru základní stavební blok pro tvorbu uživatelského rozhraní. \cite{flutterWidgets} V následující ukázce kódu \ref{lst:flutterCode} je pro příklad použito několik 
základních widgetů jako je \emph{Image} nebo \emph{Text} a taktéž layout widget zvaný \emph{Container} a \emph{Row} pro organizaci a 
rozložení vnořených widgetů na obrazovce.

\begin{lstlisting}[caption={Popis UI widgetů pomocí jazyka Dart}, label={lst:flutterCode}, language=Kotlin]
  Container(
  color: Colors.blue,
  child: Row(
    children: [
      Image.network('https://www.example.com/1.png'),
      const Text('A'),
    ],
  ),
);
\end{lstlisting}

Když Flutter potřebuje vykreslit tento blok, zavolá metodu \emph{build()} a ta vrátí podstrom widgetů, které následně vykreslí uživatelské 
rozhraní na základě aktuálního stavu aplikace. \cite*{flutterArchOverview}

Během fáze sestavování překládá Flutter widgety vyjádřené v kódu (například kód \ref{lst:flutterCode}) do odpovídajícího stromu elementů viz obrázek \ref{fig:flutter_trees}, přičemž každý widget má jeden element a 
každý prvek představuje určitou instanci widgetu v daném umístění stromové hierarchie. \cite*{flutterArchOverview}


\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{flutter_trees.png}
  \caption{Flutter build proces}
  \label{fig:flutter_trees}
\end{figure}



\subsection{Compose Multiplatform}

Compose Multiplatform je framework sloužící k tvorbě uživatelských rozhraní použitelných na vícero platformách za 
jehož vývojem stojí společnost JetBrains. \cite{composeMultiplatform} Je založen na toolkitu zvaném Jetpack Compose, který je aktuálně 
doporučovaný k tvorbě nativních uživatelských rozhraních na platformě Android. \cite{jetpack}

Podporuje platformy jako Android, iOS (Alpha), Windows, MacOS, Linux a Web (experimentální). \cite{composeMultiplatform}

\medskip

\subsection*{Klíčové vlastnosti Compose Multiplatform}

\myparagraph{Deklarativní zápis UI} 
Používá deklarativní syntaxi pro popis uživatelského rozhraní. \cite{KMPUseCases}

\myparagraph{Jednotný kód pro různé platformy} 
Umožňuje sdílet kód pro Android, iOS, web i desktop. \cite{composeMultiplatform}

\myparagraph{Snadné migrace díky postupné integraci} 
Díky KMP je možné postupně implementovat jednotlivé částí aplikace i do již existujících aplikací s minimálním rizikem oproti
ostatním multiplatformním technologiím. \cite{KMP}

\myparagraph{Znovupoužitelnost Kotlin kódu} 
Díky KMP je možné použít některé části kódu z již existujících Android aplikací i na ostatních platformách.

\myparagraph{Programovací jazyk Kotlin} 
Frontendová i backendová část aplikace jsou psány v jazyce Kotlin pro bezproblémovou integraci se serverovou částí.

\myparagraph{Podpora od JetBrains}
Poskytuje stabilní podporu od vývojářského týmu JetBrains.

\subsection*{Architektura frameworku Compose Multiplatform} \label{ComposeArch}
Jelikož je framework Compose Multiplatform z velké části založen na frameworku Jetpack Compose, tak v této kapitole bude probírána
právě architektura toho frameworku, která bude doplněna o drobné rozdíly mezi těmito dvěma frameworky.

V porovnání s ostatními dříve zmíněnými frameworky slouží tento framework pouze k tvorbě multiplatformního UI a z toto důvodu je převážně 
používán s toolkitem Kotlin Multiplatform, který dané aplikaci poskytuje i multiplatformní aplikační logiku. Jelikož se jedná o základní 
komponentu bez které by Compose Multiplatform nevznikl, tak je tomuto toolkitu věnována celá kapitola \ref{kmpSection}.

Pro lepší ukázku toho, z jakých částí se typická multiplatformní mobilní aplikace skládá slouží následující obrázek \ref{fig:composeIOS}, který
vizualizuje propojenost frameworku Compsose Multiplatfom s toolkitem Kotlin Multiplatfom (KMP). Dále vizualizuje 
vztah platformě specifických knihoven pro tvorbu UI jako SwiftUI k frameworku Compose Multiplatform.
Compose Multiplatform lze nicméně použít i s technologiemi pro tvorbu UI jako je UI kit pro platformu iOS nebo
Android views  pro platformu Android, od kterých je postupně upouštěno a přechází se k deklarativním frameworkům jako je Jetpack Compose nebe SwiftUI.  

\begin{figure}[H]
  \centering
  \includegraphics[width=.7\textwidth]{composeIOS.png}
  \caption{Compose Multiplatform iOS}
  \label{fig:composeIOS}
\end{figure}

TODO % doplnit neco o KMP a APIs

Co se týče samotného UI kódu, tak ten se skládá z jednotlivým funkcí označených anotací \code{@Composable}, která v těle obsahuje další
\textit{Composable} funkce (viz výpis kódu \ref{lst:ComposeCode}) jako jsou například \code{Column} pro strukturování vnořených elementů do sloupce nebo \code{Text} pro zobrazení
textu na obrazovce. 

\begin{lstlisting}[caption={Popis UI widgetů pomocí jazyka Kotlin}, label={lst:ComposeCode}, language=Kotlin]
@Composable
fun MyComposable() {
    Column {
        Text("Hello")
        Text("World")
    }
}
\end{lstlisting}

Takto strukturovaný kód může být následně frameworkem vykreslen na obrazovku k čemuž dochází v těchto třech následujících fázích:

\myparagraph{Composition}
Během této fáze Jetpack Compose vytvoří stromovou strukturu reprezentující UI komponenty, které mají být vykresleny.\cite{jetpackPhases} 
Tato stromová struktura je tvořena na základě do sebe zanořených Composable funkcí, které představují jednotlivé prvku uživatelského rozhraní.
Lepé tutu skutečnost reprezentuje obrázek \ref{fig:semantics-ui-tree}, na kterém je vidět, že nejspodnější vrstvu UI, reprezentuje kořenový uzel
sémantického stromu a následující vnořené prvky jsou jeho potomky.

\begin{figure}[H]
  \centering
  \includegraphics[width=.5\textwidth]{semantics-ui-tree.png}
  \caption{UI struktura a její sémantický strom}
  \label{fig:semantics-ui-tree}
\end{figure}

\myparagraph{Layout}
Během této fáze se jednotlivým komponentám určí na jakých pozicích se mají vykreslit a jakou mají mít šířku a výšku.
Compose během této fáze prochází strom UI komponent tak, že nejprve změří velikost svých potomků (pokud existují) a následně se 
na základě těchto měření rozhodně o vlastní velikosti. Nakonec umístí každého potomka relativně ke své pozici.\cite{jetpackPhases}

Díky použití tohoto algoritmu je k prostupu celého stromu zapotřebí navštívit každý uzel pouze jednou, což je výhodné jelikož
s přibývajícími uzly roste čas potřebný k průchodu celého stromu pouze lineárně. \cite{jetpackPhases}

\myparagraph{Drawing}
V rámci poslední fáze dochází s samotnému vykreslení komponent na obrazovku koncového zařízení. \cite{jetpackPhases}
Compose během této fáze znovu postupně prochází strom UI elementů od kořene až do listů a každý element tohoto stromu vykreslí sám sebe 
na pozici určenou během Layout fáze. \cite{jetpackPhases}

\subsubsection{Kotlin Multiplatform} \label{kmpSection}


%https://blog.jetbrains.com/kotlin/2023/11/kotlin-multiplatform-stable/#use-the-power-of-the-growing-kotlin-multiplatform-ecosystem

Kotlin Multiplatform je často základním kamenem pro tvorbu multiplatformních aplikací založených na Compose Multiplatform a to
z toho důvodu, že díky KMP je možné implementovat multiplatformní aplikační logiku, která může doplňovat multiplatformní UI 
poskytované frameworkem Compose Multiplatform. \cite{KMPUseCases} Důležitým rozdílem oproti ostatním multiplatformním frameworkům 
je právě ta možnost, kterou KMP případně Compose Multiplatform vývojářům poskytuje. 

Jelikož se jedná o SDK, tak umožňuje vývojářům implementovat multiplatformní funkcionality postupně, bez nutnosti implementovat 
v Kotlinu celé vrstvy aplikací. Díky tomu dává vývojářům možnost sdílet napříč platformami je ty části kódu, které mají největších
smysl implementovat pro veškeré platformy a zbylé části kódu psát v nativním jazyce pro danou platformu. \cite{KMP}
Lépe je tato skutečnost ilustrována na následujícím obrázku \ref{fig:KMP_vrstvy}, na kterém jsou vidět různé možnosti,
jakými může být KMP na daných platformách implementován.

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{KMP_vrstvy.png}
  \caption{Možnosti implementace KMP}
  \label{fig:KMP_vrstvy}
\end{figure}

Zároveň je tento obrázek ukázkou toho, jak může probíhat migrace z již naimplementované nativní aplikace na aplikaci
multiplatformní. Nejprve je tedy možné implementovat jen malou část aplikační logiky pro víro platforem a postupem času přesouvat
do multiplatformní části aplikace například celé vrstvy starající se o prezentační, datovou nebo jinou aplikační logiku. \cite{KMPUseCases}

Aby ale k takové migraci mohlo dojít, tak je zapotřebí aby pro technologie používané v původní nativní aplikaci existovali multiplatformní
knihovny nebo alespoň jejich ekvivalent.

\subsubsection*{Multiplatformní knihovny}
Společnost JetBrains ve svém článku z konce roku 2023 zmiňuje, že existuje již přes 1500 KMP knihoven s tím, že ještě v roce 2020
jich bylo pouze několik málo desítek. \cite{KMPstable}

%Jeho hlavním úkolem je sdílení kódu na mobilních platformách. 
Právě počet a vyspělost těchto knihoven se podle společností, které již KMP používají jeví jako zatím jedna z nejslabších stránek KMP (viz kapitola \ref{kmpInPractise}).

V případě, že žádná vhodná knihovna není k dispozici, tak je zde stále možnost čehož je možné docílit díky funkcionalitě jazyka Kotlina
zvané Expected a actual deklarace.

\subsubsection*{Expected a actual deklarace}\label{expectActual}
Deklarace \textit{expected} a \textit{actual} umožňují přistupovat k platformě specifickým API z Kotlin Multiplatform modulů. \cite{KMPExpectActual}
Nejprve je ve společné části potřeba vytvořit například třídu nebo funkci u které chceme aby její obsah byl implementován typicky pomocí
platformě specifických knihoven a tuto část v rámci společného modulu označit klíčovým slovem \code{expect}. \cite{KMPExpectActual} Její implementaci následně provést v rámci
platformě specifického kódu. Tato implementace musí být provedena pod stejným názvem a ve stejném balíku jako deklarace ve společném modulu
a musí být označena klíčovým slovem \code{actual}. \cite{KMPExpectActual}

Během kompilace pak Kotlin kompilátor každou deklaraci s klíčovým slovem \code{expect} sjednotí s příslušnou actual deklarací pro danou platformu
a vygeneruje z ní jednu deklaraci obsahující actual implementaci. \cite{KMPExpectActual}

\subsubsection*{Struktura KMP projektů}\label{projectStructure}
Jak již bylo zmíněno v úvodu, tak jedním z hlavních cílů multiplatformního vývoje je mít 
jeden kód, který by bylo možné zkompilovat tak, aby byl spustitelný je všech požadovaných platformách. To však u KMP není vždy 
možné, a proto je nutné, zvlášť rozdělit kód, který je určen pro všechny platformy a kód, který je platformě specifický. 

\myparagraph{Společný kód}
Jedná se o kód sdílený mezi různými platformami a měl by být seskupen v adresáři \code{commonMain}. \cite{KMPCommonCode}

Kotlin kompilátor na základě zdrojových kódů umístěný v tomto adresáři generuje sadu binárních souborů specifických pro danou platformu. \cite{KMPCommonCode}
Při kompilaci tak může z téhož kódu vygenerovat několik souborů, jako například soubory pro \textit{Java Virtual Machine (JVM)}, 
anebo spustitelné soubory pro nativní platformu. \cite{KMPCommonCode}

Nicméně i pro jednotlivé platformy existují zařízení, která například využívají specifickou architekturu, a proto je třeba pro 
tato zařízení zkompilovat tento kód jiným způsobem.

K této kompilaci KMP používá technologii Kotlin/Native, díky které
je možné sestavovat kód napsaný v jazyce Kotlin do nativních binárních souborů a ten díky tomu může běžet i bez JVM. \cite{kotlinNative}

Pro ukázku toho, jaká zařízení jsou technologií Kotlin/Native podporovaná slouží následují obrázek \ref{fig:KMP_struktura}

\begin{figure}[H]
  \centering
  \includegraphics[width=.7\textwidth]{full-template-hierarchy.png}
  \caption{Hierarchická struktura KMP \cite{KMPHierarchi}}
  \label{fig:KMP_struktura}
\end{figure}

Při této vizualizaci veškerých podporovaných zařízeních se ale ukazuje, že rozřazení kódu do vhodných balíčků je pro orientaci v 
multiplatformním projektu založeném na KMP klíčové. Implementace kódu pro každé jednotlivé zařízení by byla zbytečná, jelikož
velké části kódu i těchto platformě specifických kódu mohou být součástí společného kódu. Nesdílení toho kódu s ostatními platformami
by tak zapříčinilo duplikaci velké části kódu. 

Aby se tomuto zabránilo je vhodné využít dříve zmíněné hierarchické struktury a využít takzvané \textit{source sets}, které slouží 
pro jakési seskupení kódů specifických pro konkrétní zařízení nebo platformy. Pro lepší představu o tom jak jsou jednotlivé
\textit{source sets} definovány slouží obrázek \ref{fig:dependson-tree-diagram},
který vizualizuje celkem pět zadefinovaných \textit{source sets} a to konkrétně \code{commonMain}, \code{androidMain}, 
\code{iosMain}, \code{iosSimulatorArm64} a \code{iosArm64}. V rámci těchto zdrojových sad mohou být následně implementovány
platformě specifické knihovny čemuž se detailněji věnuje kapitola \textit{Gradle \ref{gradleChapter}} v implementační části práce.

%pro které může být například použit specifický kód nebo 
%Díky nim je možné sdílet společný kód pouze mezi některými podporovanými platformami. \cite{KMPHierarchi}
%%. Pomocí nich je možné sestavovat 
%projekt pro vícero zařízení zároveň.

\begin{figure}[H]
  \centering
  \includegraphics[width=.9\textwidth]{dependson-tree-diagram.png}
  \caption{Strom závislostí}
  \label{fig:dependson-tree-diagram}
\end{figure}

Ze struktury těchto zdrojových sad zároveň vyplývá koncová struktura projektu, která se ve většině případů obsahuje adresář pro sdílený kód (\code{commonMain}), 
který smí obsahovat pouze kód a případné knihovny, které jsou multiplatformní a pokrývají tak veškeré platformy používané v projektu.

A dále na adresáře pro vybrané platformy jako například \code{AndroidMain}, \code{iosMain}, které již mohou být závislé na pouze platformě specifický knihovnách.

\subsubsection*{Aktuální použití KMP v praxi} \label{kmpInPractise}
% Mezi další důvody patří taktéž lepší zastupitelnost jednotlivých členů týmu a to díky me

I přesto, že je KMP ve stabilní verzi teprve od listopadu 2023 \cite{KMPstable}, tak tuto technologii používá již několik světově 
známých firem v produkčním nasazení jako je například Forbes či McDonald's. Forbes uvádí, že právě díky KMP dokáží sdílet až 80 \%
aplikační logiky napříč platformami Android a iOS. \cite{KMPinForbes} 
Druhý ze jmenovaných McDonald's jako hlavní výhody uvádí jednodušší testování \cite{KMPinMcDonalds}

Naopak mezi největší výzvy, které obě společnosti ve svých souhrnech uvádějí patří adaptace na KMP prostředí (především iOS vývojářů) nebo
nedostatečné množství potřebných multiplatformních knihoven (případně jejich nedostatečná vyspělost). \cite{KMPinForbes} \cite{KMPinMcDonalds}

Pro porovnání s 

\emph{"Od této doby jsme vyvinuli a v produkci provozujeme několik mobilních aplikací. Ze zkušenosti vidíme, že při jejich vývoji dokážeme 
sdílet cca 60–70 \% kódu na platformu. V případě vývoje na dvě platformy to znamená, že v součtu dokážeme ušetřit minimálně třetinu 
nákladů na vývoj, plus s tím související další náklady na věci typu testování (v tomto případě snížení až na polovinu)."}

\begin{figure}[H]
  \centering
  \includegraphics[width=.7\textwidth]{chart-KMP-vs-native.png}
  \caption{Množství kódu KMP vs native}
  \label{fig:KMP_vs_native}
\end{figure}

Pro upřesnění je ještě potřeba zmínit, že veškeré vyjmenované společnosti, využili pouze možnosti sdílení logiky a nepoužívají
tak sdílené UI pomocí Compose Multiplatform.

To se ukázalo i na průzkumu, který provedla společnost JetBrains v roce 2021, kde pouze 3,8~\% respondentů odpovědělo, že byli schopni sdílet UI ve svých aplikacích.

Pro ukázku veškerých částí, které respondenti sdíleli ve svých aplikacích napříč platformami slouží obrázek \ref{fig:KMPSurvey}, který jednoznačně ukazuje, že
mezi nejčastěji sdílené části aplikací patří datová a síťová vrstva.  

\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{survey-results-q1-q2-22-light.png}
  \caption{KMP průzkum}
  \label{fig:KMPSurvey}
\end{figure}

\section{Flutter vs React Native vs Compose Multiplatform}


\subsection{Porovnání výkonu}

Mezi klíčové parametry, kvůli kterým většina firem upřednostňuje vývoj nativních aplikací, patří především výkon
nativních aplikací. Z toho důvodu se následující podkapitola věnuje právě porovnání výkonu a dalších parametrů multiplatformních aplikací s
nativními verzemi aplikací. 

Pro testování byly použity toolkity pro tvorbu nativního UI pro platformu Android (Jetpack Compose) a iOS (SwiftUI)
v porovnání s multiplatformním frameworkem Compose Multiplatform a aktuálně nejpoužívanějším multiplatformním
frameworkem zvaném Flutter. \cite{crossPlatformFrameworksStats} 

Mezi hlavní testované parametry patřil čas nastartování testované aplikace a její velikost.

\subsection*{Ukázková aplikace}
Pro porovnání důležitých parametrů byla pro test vytvořena jednoduchá aplikace, která obsahovala jednu obrazovku, 
načetla obrázky z veřejného API a zobrazila je v horizontálním seznamu. 
Na každý obrázek šlo kliknout a zobrazit jej přiblížený pod seznamem. 

Veškeré testy proběhli na zařízeních Pixel 4a a iPhone 12 Mini a byly opakovány celkem pětkrát.

%Verze Compose Multiplatform 1.4

% replikovat test


\myparagraph{Velikost aplikace} 

Na obrázku \ref{fig:chart_app_sizes} je vidět, že velikost aplikace založené na Compose Multiplatform je identická
s velikostí nativní aplikace pro Android. Je tomu tak z toho důvodu, že výsledná aplikace pro Android neobsahuje kód 
pro jiné platformy. \cite{} Kdežto u velikosti iOS aplikace je situace výrazně jiná. Samotná aplikace pro iOS je v porovnání
s její nativní aplikací o 23,1 MB větší. Tento rozdíl ve velikosti je způsoben především grafickou 2D knihovnou Skia,
která je na platformě Android dostupná, kdežto na platformě iOS ne a proto tam musí být spolu s aplikací dodána. \cite{}

Zajímavé je následné porovnání s velikostí aplikace založené na frameworku Flutter, jelikož ta, stejně jako Compose
Multiplatform využívá knihovnu Skia, ale i přesto je o něco menší než Compose Multiplatform aplikace na platformě iOS.
Součástí aplikace Flutter ještě vlastní engine, který je součástí aplikace a zvětšuje tak velikost aplikace asi o 3–4 MB pro Android a 10 MB 
pro iOS. \cite{flutterSize}

\begin{figure}[H]
  \centering
  \includegraphics[width=.7\textwidth]{chart_app_sizes.png}
  \caption{APK/IPA size in megabytes}
  \label{fig:chart_app_sizes}
\end{figure}

\myparagraph{Rychlost spuštění aplikace}

Při porovnání rychlosti spuštění Compose Multiplatform aplikace na platformě Android není mezi rychlostmi téměř žádný
rozdíl stejně tak jako tomu při porovnání velikosti aplikací v předchozí kapitole. O něco delší dobu spuštění měla
aplikace napsaná pomocí frameworku Flutter, která se spouštěla v průměru o 221 ms déle než Compose Multiplatform aplikace. 
Toto zpomalení je s nejvyšší pravděpodobností způsobeno dobou spuštění Flutter Enginu, což by korespondovalo s oficiální
Flutter dokumentací. \cite{flutterPerformance}

U posledního porovnání na platformě iOS se doba spuštění aplikací založených na Compose Multiplatform a frameworku 
Flutter o tolik nelišila od nativní aplikace.
% // TODO posledni cast porovnani

% // TODO posledni tabulka pro porovnani https://github.com/jacobras/flutter-vs-native-vs-kmp

\begin{figure}[H]
  \centering
  \includegraphics[width=.7\textwidth]{chart_startup_times.png}
  \caption{Časy nastartování jednotlivých aplikací}
  \label{fig:chart_startup_times}
\end{figure}

\subsection{Náročnost implementace}
I přesto, že je náročnost implementace do jisté míry subjektivní záležitostí, tak existuje několik aspektů, které mohou k porovnání 
náročnosti implementace Compose Multiplatform s ostatními frameworky posloužit. 

TODO

\section{Limitace Compose Multiplatform oproti nativnímu řešení} 
% to se tyka KMP ne compose Multiplatform
Jak již bylo zmíněno v kapitole \textit{Kotlin Multiplatform \ref{kmpSection}}, tak jedním z největších problému multiplatformního vývoje pomocí KMP je
především nedostatečné množství knihoven. 

Co se týče UI, tak zde je situace díky možnosti využití Jetpack Compose o něco lepší. Většina omezení, která jsou
aktuálně spjata s UI se týká především plynulosti a nebo použití nativně vypadajících komponent na platformě iOS.
Ta v její nativní podobě používá styl zvaný Cupertino, který frameworkem Compose Multiplatform není aktuálně oficiálně podporován. 
Co se týče plynulosti UI na platformě iOS, tak aktuálně se nejvíce řeší problém s rychlostí vykreslování.

Většina výše zmíněných problémů se již řeší a je zmíněna v Kotlin Multiplatform vývojářském plánu pro rok 2024. \cite{KMPRoaddMap} Konkrétně
se jedná o veškeré zmíněné o problémy kromě zařazení HarmonyOS mezi podporované platformy.% // todo 
V tomto plánu je mimo jiné uvedeno, že aktuální prioritu číslo jedna je dostání frameworku Compose Multiplatform na platformě iOS do verze Beta. \cite{KMPRoaddMap}

\chapter{Návrh}
V rámci této kapitoly bude nejprve vybrána aplikace, která bude použita k otestování použitelnost Compose Multiplatform frameworku a následně
bude tato aplikace navržena tak, aby splnila veškeré vytyčené cíle z úvodní kapitoly \textit{Cíle práce \ref{goals}}.

Po vybrání typu aplikace následuje podkapitola věnující návrhu vhodných případů užití, které je vhodné specifikovat jednak aby bylo zřejmé jací 
uživatelé budou danou aplikaci používat, tak z pohledu na jakých zařízení případně platformách ji budou využívat. 
Zároveň vhodné skloubení případů užití s grafickou podobou UI, tak aby nejčastější uživatelovi cílem bylo možné splni s co nejmenší dávkou úsilí, 
je pro správný návrh UI klíčové. 
což obecně vede k intenzivnějšímu používaní a oblibě aplikace.


Další fáze návrhu je věnována vytyčení funkčních požadavků ...

Dále je v rámci této kapitoly navržena architektura aplikace, která je pro následné navržení a správné fungování UI nezbytná. 

Podkapitola \textit{Návrh architektury} se tedy věnuje rozebrání používaných typů architektury pro mobilní zařízení a následnému detailnímu
rozebrání jednotlivých vrstev vybrané architektury.

V poslední části návrhu je přistoupeno k samotné návrhu uživatelského rozhraní aplikace a to nejprve za použití takzvaných wireframe modelů,
následně návrhu design systému a nakonec k návrhu konečné podoby UI včetně grafických prvků.



\section{Výběr aplikace pro implementaci}
Základním požadavkem bylo vybrat takovou aplikaci, ve které by bylo možné použít velké množství různých komponent, jejichž funkčnost by následně mohla být otestována
na různých platformách.
%které by bylo možné použít napříč různými platformami.
Mezi další požadavky patřilo zaměření se na kritické problémy, které aktuálně multiplatformní vývojem provází. 
Mezi takové problémy patří například využití funkcí, které jsou silně spjaty s hardwarem koncových zařízení jako je použití jednotné navigace, fotoaparátu 
nebo služeb lokalizace.

Z těchto důvodů byla k implementaci vybrána aplikace sloužící pro občany měst či obcí, která kombinuje veškeré funkční požadavky, které plynou ze zadání.

Tato aplikace by sloužila občanům k získání informací o aktuálních novinkách, pořádaných akcích nebo by jim například umožňovala vyhledat a zaplatit parkovné.
TODO rozsirit uvodni popis aplikace provest analyzu co by takova apk mela obsahovat

Na základě toho popisu byli vybrány následující případy užití.

\section{Případy užití}
Případy užití (use cases) jsou scénáře popisující, jakým způsobem by případní uživatelé aplikace mohli využívat určité funkce nebo
vlastnosti aplikace k dosažení svých cílů. \cite{} Tyto scénáře zachycují interakce mezi uživatelem a systémem a popisují, jak systém reaguje na určité vstupy od 
uživatele. Zároveň popisují jakou zpětnou vazbu uživatel na základě provedených vstupů od systému dostává.

Každý případ užití obvykle obsahuje následující prvky:

\begin{itemize}
  \item Název: Stručný název, který popisuje, co uživatel chce dosáhnout.
  \item Aktor: Uživatel nebo systém, který spouští případ užití.
  \item Popis: Podrobný popis scénáře, který obsahuje kroky, které uživatel vykonává, a odpovědi systému na tyto kroky.
  \item Předpoklady: Podmínky nebo situace, které musí být splněny, aby mohl být případ užití spuštěn.
  \item Výsledek: Očekávaný výsledek akce provedené uživatelem.
\end{itemize}

\myparagraph{UC1 Zobrazení aktuálních novinek} 
Tento případ užití popisuje jak mohou občané prostřednictvím aplikace získat přístup k aktuálním novinkám a důležitým oznámením ze svého města 
nebo obce. Tato funkce umožní občanům zůstat informováni o dění ve svém okolí.

\begin{enumerate}
  \item Systém uživateli zobrazí aktuální seznam aktualit z webových stránek města a dalších informačních zdrojů.
  \item Uživatel si vybere aktualitu, která ho zaujme.
  \item Systém uživateli zobrazí detail vybrané aktuality obsahující její název, obsah, datum vytvoření, obrázek a případně odkazy na další zdroje.
\end{enumerate}

\myparagraph{UC2 Zobrazení aktuálních událostí} 
Tento případ užití popisuje jak mohou občané prostřednictvím aplikace získat přehled o aktuálně připravovaných akcích, událostech a kulturních 
aktivitách v jejich městě nebo obci. 

\begin{enumerate}
  \item Systém uživateli zobrazí aktuální seznam událostí z webových stránek města, divadel, kin a dalších informačních zdrojů.
  \item Uživatel si vybere událost, která ho zaujme.
  \item Systém uživateli zobrazí detail vybrané události obsahující její název, popis, datum konání, místo konání obrázek a případně odkazy na další zdroje.
\end{enumerate}

\myparagraph{UC6 Filtrování zobrazených událostí za základě času}
Tento případ užití popisuje jak mohou občané filtrovat zobrazené události podle na základě datu konání daných událostí.

\begin{enumerate}
  \item Systém uživateli zobrazí seznam událostí z webových stránek města, divadel, kin a dalších informačních zdrojů s nejbližším datem konání, který 
  je rozdělen na základě kategorií jako například kino, divadlo, hudba atd..
  \item Uživatel si vybere konkrétní den pro který chce zobrazit konané události.
  \item Systém uživatel vrátí výpis pro vybraný den a události rozdělí na základě kategorií, do kterých vyfiltrované události spadají.
\end{enumerate}

\myparagraph{UC3 Zobrazení kontakty na místní úřady}
Aplikace může poskytovat možnost rychlého a snadného získání kontaktu na místní úřady nebo správními orgány. %Uživatelé budou moci prostřednictvím aplikace zasílat otázky, stížnosti nebo žádosti o pomoc a získávat odpovědi a podporu přímo ze svého mobilního zařízení.

\begin{enumerate}
  \item Systém uživateli zobrazí seznam městských institucí.
  \item Uživatel vybere konkrétní instituci, pro kterou chce zobrazit detailní informace.
  \item Systém vrátí podrobné informace o vybrané instituci.  
\end{enumerate}

\myparagraph{UC4 Nahlášení závady ve městě}
Aplikace dá občanům možnost hlásit závady, které je potřeba ve městě opravit.

\begin{enumerate}
  \item Systém uživateli zobrazí formulář pro k vyplnění městských institucí.
  \item Uživatel vyplní název závady, nahraje fotografii závady, vyplní místo, kde se závada nachází, vybere kategorii závad do, které závada spadá a 
  záznam o závadě odešle.
  \item Systém závadu odešle příslušnému orgánu a uživateli vrátí informaci o 
  
  \item TODO rozdvojka spatne dobre vyplnene
\end{enumerate}

\myparagraph{UC5 Propojení s YouTube kanálem města}
Aplikace dá občanům možnost konzumovat aktuální novinky prostřednictvím videí z městského YouTube kanálu. Díky intuitívnímu propojení...

\begin{enumerate}
  \item 
  \item 
\end{enumerate}

\myparagraph{UC7 Vyhledání parkovacích zón}
Aplikace umožňuje občanům města jednoduše a rychle vyhledat veškeré parkovací zóny ve městě včetně informace o provozní době parkovací zóny.

\begin{enumerate}
  \item Systém uživateli zobrazí mapu parkovacích zón ve jeho obci.
  \item Uživatel vybere parkovací zóny pro kterou chce zobrazit detailní informace.
  \item Systém vrátí uživateli detailní informace týkající se vybrané parkovací zóny.
\end{enumerate}

\myparagraph{UC8 Platba parkovného}  podTask UC7
Aplikace umožní uživatelům snadno a rychle zaplatit parkovné prostřednictvím svého mobilního zařízení. Uživatelé mohou zadat informace o svém vozidle, 
délce parkování a provedení platby online, což jim ušetří čas a nepohodlí spojené s hledáním parkovacího automatu nebo mincí.

\begin{enumerate}
  \item Systém uživateli zobrazí mapu parkovacích zón ve jeho obci.
  \item Uživatel vybere parkovací zóny pro kterou chce zaplatit parkování.
  \item Systém vrátí uživateli detailní informace týkající se vybrané parkovací zóny s odkazem na zaplacení.
  \item Uživatel na detailu vybrané zóny vybere akci zaplatit parkovné.
  \item Systém uživatele přesměruje na platební systém používaný daným městem pro platbu parkovného s předvyplněnou informací o vybrané parkovací zóně.
\end{enumerate}

\myparagraph{UC7 Zobrazení dopravy na mapě města}
Tento případ užití popisuje jak mohou občané města jednoduše a rychle zobrazit vytíženost silnice ve městě.

\begin{enumerate}
  \item Systém uživateli zobrazí mapu vytíženost silnice ve městě.
\end{enumerate}

Pro dotvoření představy o tom jak jsou spolu jednotlivé případy užití navzájem propojeny slouží obrázek \ref{fig:use_case_diagram}, na který zároveň 
obsahuje i typy uživatelů pracujících s navrženou aplikací.

Co se týče vzájemných vazeb, tak zde je věno

Use case diagram
\begin{figure}[H]
  \centering
  \includegraphics[width=.99\textwidth]{Use case diagram.png}
  \caption{Use case diagram}
  \label{fig:use_case_diagram}
\end{figure}

\myparagraph{Aktéři}
Hlavními uživateli systému jsou především občané příslušného města, kteří budou aplikaci využívat za účelem splnění cílů z předchozí podkapitoly.

Dalším aktérem toto systému je informační systém (IS) města, který aplikaci poskytuje potřebná data.

TODO jaci uzivatel budou aplikaci použivat

\bigskip

Případy užití jsou klíčovým nástrojem pro pochopení potřeb uživatelů a návrhu funkcionalit aplikace tak, aby co nejlépe odpovídaly těmto potřebám. 
Jsou také důležitým zdrojem pro testování a validaci funkčnosti aplikace, protože je na jejich základě možné ověřit, zda systém správně reaguje na očekávané 
uživatelské interakce. 

Na jejichž základě je proto založeno koncové testování celé aplikace čehož je využito k tvorbě UI testů v kapitole \textit{Testování \ref{testsSection}}.

Na základě takto sepsaných případech užití je nyní možné sepsat funkční požadavky.

\section{Funkční požadavky}
Funkční požadavky definují konkrétní vlastnosti a chování aplikace, které zajistí, že bude aplikace pro občany měst či obcí 
užitečná, efektivní a snadno použitelná.

TODO piorita 5 slozitost viz grofetom

\myparagraph{Zobrazení novinek}
Možnost přidávat, editovat a mazat novinky a oznámení.
Zobrazení aktuálních novinek na domovské obrazovce aplikace.
Možnost filtrovat novinky podle kategorie nebo data.

\myparagraph{Zobrazení událostí}
Zobrazení kalendáře s událostmi, akcemi a důležitými daty.
Možnost procházet události v kalendáři dle data, místa nebo typu události.
Možnost přidávat nové události do kalendáře.
Možnost filtrovat události podle kategorie nebo data.

\myparagraph{Platební brána pro parkovné}
Možnost provádět platby parkovného prostřednictvím aplikace.
Zadání informací o vozidle, parkovacím místě a délce parkování.
Zobrazení historie plateb a možnost platit opakovaná parkování.

\myparagraph{Možnost vyhledání a kontaktování místních úřadů, policie nebo zdravotního střediska}
Zobrazení kontaktních informací a pracovní doby úřadů.
Možnost zaslat otázku, stížnost nebo žádost přímo prostřednictvím aplikace.

\myparagraph{Navigace a mapy}
Integrace mapových služeb pro zobrazení umístění událostí a místních služeb.
Možnost vyhledávání tras a navigace v rámci města nebo obce.

\myparagraph{Podpora více jazyků}
Možnost nastavení jazyka aplikace dle uživatelských preferencí.
Zobrazení obsahu a textů v různých jazycích.

\myparagraph{Feedback a hodnocení}
Možnost zaslat zpětnou vazbu, hodnocení nebo recenzi na aplikaci.
Zpětná vazba od uživatelů a možnost sledovat spokojenost s aplikací.


\myparagraph{Pokrytí případů užití} 
Pro ověření, že takto sepsané funkční požadavky pokrývají všechny případy užití byla vytvořena následující tabulka pokrytí.

\begin{table}[H]
  \centering
  \begin{tabular}{|l|c|c|c|c|c|c|c|c|}
  \hline
  %\multicolumn{9}{|c|}{Functional Requirements} \\ \hline
   & F1 & F2 & F3 & F4 & F5 & F6 & F7 & F8  \\ \hline
  UC1  & $\ast$ &        &        &        &        &        &        &         \\ \hline
  UC2  & $\ast$ &        &        &        &        &        &        &         \\ \hline
  UC3  & $\ast$ &        &        &        &        &        &        &         \\ \hline
  UC4  &        & $\ast$ &        &        &        &        &        &         \\ \hline
  UC5  &        &        &        & $\ast$ &        &        &        &         \\ \hline
  UC6  &        &        & $\ast$ &        &        &        &        &         \\ \hline
  UC7  &        &        &        &        & $\ast$ & $\ast$ & $\ast$ & $\ast$  \\ \hline
  UC8  &        &        &        &        &        & $\ast$ & $\ast$ & $\ast$  \\ \hline
  UC9  &        &        &        &        &        &        &        & $\ast$  \\ \hline
  UC10 &        &        &        &        &        &        &        & $\ast$  \\ \hline
  UC11 &        &        &        &        &        &        &        & $\ast$  \\ \hline
  \end{tabular}
  \caption{Pokrytípřípadů užití funkčními požadavky aplikace}
  \label{table:tabulkaPokryti}
\end{table}
  

\section{Návrh architektury}
Navržená architektura se z velké části drží architektonických principů shrnutých v Android dokumentaci. \cite{andDocArch}

TODO možné architektury pro vyvoj mobilních aplikací

\subsection*{Důležité principy}

\myparagraph{Separation of concerns}
Separation of concerns je princip návrhu softwaru, který popisuje důležitost oddělení různých funkcionalit do samostatných, dobře definovaných a izolovaných částí.
Hlavním cílem tohoto principu je zlepšit modularitu, udržitelnost, znovupoužitelnost a spravovatelnost kódu.

Princip oddělení zájmů rozděluje systém na jednotlivé komponenty nebo moduly, přičemž každý z nich se zabývá jednou konkrétní 
oblastí funkcionality. Každá část systému má jasně definované rozhraní, které umožňuje interakci s ostatními částmi. 
Tímto způsobem lze snadněji spravovat a udržovat kód, protože změny v jedné části systému nemusí mít nežádoucí dopady na ostatní části.

Příklady oddělení zájmů zahrnují oddělení prezentační vrstvy od logiky aplikace (Model-View-Controller), oddělení datového přístupu od 
podnikové logiky (Repository pattern), a oddělení různých vrstev aplikace (např. vrstva uživatelského rozhraní, aplikační logika, datová vrstva). 

\myparagraph{Unidirectional Data Flow}
Unidirectional Data Flow (jednosměrný tok dat) je architektonický vzor, který popisuje způsob, jakým data cestují skrz aplikaci. 
V tomto přístupu data proudí v jednom směru, což znamená, že existuje jasný a jednoznačný tok dat od zdroje až po jejich konečný cíl.
Takovýto přístup například umožňuje efektivní aktualizaci uživatelského rozhraní v reakci na změny dat a přispívá k jednoduchosti, 
předvídatelnosti a údržnosti softwarových aplikací.

\myparagraph{Single source of truth}
Princip Single Source of Truth (SSOT) je koncept v softwarovém inženýrství, který zdůrazňuje, že v aplikaci by měl existovat jediný 
zdroj dat, který obsahuje aktuální a spolehlivé informace. Tento zdroj dat je považován za „pravdivý“ a slouží jako jediný zdroj, 
ze kterého mohou ostatní části aplikace čerpat informace. Tím se zajišťuje konzistence dat napříč aplikací a minimalizuje se riziko 
konfliktů nebo chyb v datech.

Díky použití principu SSOT jsou data v aplikaci konzistentní a snadněji spravovatelná, protože všechny komponenty a moduly aplikace pracují se stejnými 
daty. To usnadňuje údržbu a vývoj aplikace, protože úpravy a aktualizace dat lze provádět centrálně. Z hlediska kódu přispívá tento
princip k jednoznačnosti a přehlednosti, protože vývojáři vědí, kde hledat relevantní data pro různé části aplikace.

Cílem tohoto konceptu je zlepšit konzistenci, přehlednost a údržbu aplikace a poskytnout spolehlivý zdroj dat pro všechny části aplikace.


\subsection{Vrstvy architektury} \label{vrstvyArchitekturySection} 
TODO % takzvaná architektura MVVM?  ..., která uplatňuje výše zmíněné principy.
Na základě těchto principů vznikla níže popsaná architektura, která je aktuálně doporučovaná pro vývoj mobilních Android aplikací.

Ta se rozděluje do následujících třech vrstev:

\subsubsection*{UI vrstva} \label{UILayerNavrh}
UI vrstva se stará o zobrazení dat na obrazovce, která odpovídají aktuálnímu stavu aplikace. Zároveň se stará se logiku, která
se při změně těchto dat stará o opětovné překreslení UI, tak aby opět odpovídalo aktuálnímu stavu aplikace. Tohoto chování UI vrstva 
dociluje pomocí tří částí, které jsou zobrazeny na obrázku \ref{fig:arch_ui_udf} a následně detailněji popsány pod ním.

\begin{figure}[H]
  \centering
  \includegraphics[width=.5\textwidth]{arch-ui-udf.png}
  \caption{Architektura UI vrstvy}
  \label{fig:arch_ui_udf}
\end{figure}

\myparagraph{ViewModel}
Hlavní účel ViewModelu je uchovávat a spravovat data potřebná pro zobrazení na obrazovce, a to i při změnách konfigurace zařízení 
(například při otáčení obrazovky). ViewModel také poskytuje metody a události pro interakci s daty, jako je načítání dat ze zdroje, 
jejich aktualizace a předávání událostí od uživatele zpět do aplikace. Na základě těchto událostí například aktualizuje stav uživatelského
rozhraní. % (UI elementů) nebo stavu 

\myparagraph{UI state} \label{UIStateParagraph}
UI state (stav uživatelského rozhraní) je částí UI vrstvy, který popisuje aktuální stav a chování uživatelského 
rozhraní v daném okamžiku. Tento stav může zahrnovat různé informace, jako jsou aktuální hodnoty vstupních polí, stav vybraných prvků,
 aktuální zobrazené obrazovky nebo panely, stav animací a další.

UI state je důležitý pro udržování konzistence a interaktivity uživatelského rozhraní. Změny v UI stavu mohou být způsobeny uživatelskými
interakcemi jako například kliknutím na tlačítko, zadáním textu do pole, rolováním seznamu nebo mohou být vyvolány událostmi v aplikaci,
jako je získání dat ze serveru nebo jakoukoliv změnou interního stavu aplikace. 

V rámci frameworků, které k tvorbě UI používají deklarativní způsob zápisu, se často k definice stavu a jeho vlivu na UI používá funkce 
na obrázku \ref{fig:UI_function}, která zjednodušeně popisuje to, že na základě stavu je tvořeno výsledné uživatelské rozhraní.

\begin{figure}[H]
  \centering
  \includegraphics[width=.5\textwidth]{ui-equals-function-of-state.png}
  \caption{Reprezentace vztahu UI a stavu aplikace}
  \label{fig:UI_function}
\end{figure}

Správa UI stavu je důležitou součástí vývoje aplikací s uživatelským rozhraním a může být implementována pomocí různých technik a nástrojů.
Důležité je udržovat UI stav v souladu s interním stavem aplikace a zajistit jeho konzistenci a správnou aktualizaci v reakci na uživatelské 
interakce a události v aplikaci.

\myparagraph{UI Elements}
UI elements neboli prvky uživatelského rozhraní jsou komponenty tvořící vizuální část aplikace a umožňují uživatelům interagovat s aplikací.
Tyto prvky zahrnují různé vizuální komponenty, jako jsou tlačítka, textová pole, seznamy, obrázky, ikony, přepínače, posuvníky atd. díky nimž
se zobrazují data reprezentující aktuální stav aplikace nebo je pomocí nich tento stav měněn.

UI prvky jsou navrženy tak, aby poskytovaly uživatelům intuitivní způsob, jak s aplikací komunikovat a manipulovat. Každý prvek má své 
vlastnosti, jako jsou velikost, barva, text, stav atd., které lze nastavit a upravovat pomocí kódu. Tyto prvky jsou pak umístěny na obrazovce 
podle určeného rozvržení (layout), které určuje jejich pozici a vzájemné uspořádání.

UI prvky jsou základními stavebními bloky uživatelského rozhraní a hrají klíčovou roli při vytváření uživatelsky přívětivé a atraktivní aplikace. 
Jejich vhodné použití a umístění má vliv na celkový uživatelský zážitek a efektivnost aplikace.

\myparagraph{UI Events}
Nejčastějším typem UI událostí jsou takzvané uživatelské události, které jsou generovány interakcí uživatele s uživatelským rozhraním aplikace. 
Patří k nim například kliknutí myší, dotyk na obrazovce, stisknutí klávesy nebo jakékoli jiné akce prováděné uživatelem, které vyvolávají reakci v 
UI aplikace. Tyto události jsou zpracovány aplikací pomocí metod jako je například metoda \code{onClick()} a mohou spustit různé akce, které by zároveň
měli způsobit změny UI stavu.

O zpracování uživatelských událostí se většinou stará příslušný ViewModel, který nabízí veškeré funkce, které je pomocí uživatelského rozhraní možné volat.
Nicméně některé typy uživatelských událostí může UI zpracovat přímo, takovými událostmi jsou například navigování na jinou obrazovku nebo zobrazení 
informativní zprávy pomocí takzvaných \textit{Snackbars}.

\subsection*{Doménová vrstva}
Doménová vrstva typicky obsahuje způsoby užití nicméně pro menší aplikace jako je tato může být vynechána. Často se tímto způsobem "odlehčují" ViewModely,
které by jinak obsahovali příliš mnoho kódu, což by vedlo k nepřehlednosti.

V tomto projektu doménová vrstva zahrnuje deklarace výčtových typů, objektů pro datovou a modelovou vrstvu a mapovací funkce pro pro převod
objektů datové vrstvy na objekty používané v prezentační vrstvě a naopak.

Doménová vrstva by měla být nezávislá na technických aspektech aplikace a měla by se zaměřovat pouze na reprezentaci a správu doménových
 konceptů a procesů. To zjednodušuje testování, údržbu a rozšíření aplikace a umožňuje snadnou změnu technologií nebo platformy bez 
 vlivu na doménovou logiku.

\subsection*{Datová vrstva}
%Datová vrstva se stará o správu dat, která mohou být aplikaci poskytnuta například uživatelem nebo nějakou externí službou.
%he data layer that contains the business logic of your app and exposes application data.


Datová vrstva se zabývá persistencí dat a komunikací s datovými úložišti, jako jsou
databáze, soubory nebo vzdálené API. Jejím hlavním úkolem je poskytovat rozhraní mezi doménovou logikou aplikace a datovými zdroji, 
aby bylo možné ukládat, načítat, aktualizovat a mazat data podle potřeby.

K tomu aby aplikace fungovala, tak jak bylo popsáno v úvodu této kapitly, je zapotřebí aby datová vrstva této aplikace obsahovala mechanismy pro
 získání dat z informačních systému města. Jelikož se na základě provedené analýzy data v indormačních systémech nachází na ... ve formatu XML, 


 byla proto navržena služba získávající tato data ze vzdáleného datového zdroje (IS města) tak jak se tomu v levé části obrázku \ref{fig:arch_data_layer}. 

Pro perzistenci těchto dat byla vybrána SQL databáze, která se stará poskytnutí dříve načtených dat v případech, kdy aplikace nemá přístup k internetu.


\begin{figure}[H]
  \centering
  \includegraphics[width=.5\textwidth]{data_layer_diagram.png}
  \caption{Architektura datové vrstvy}
  \label{fig:arch_data_layer}
\end{figure}

% \begin{figure}[H]
%   \centering
%   \includegraphics[width=.3\textwidth]{data_layer_diagram_principle.png}
%   \caption{Architektura datové vrstvy}
%   \label{fig:arch_data_layer_principle}
% \end{figure}

Mezi důležité prvky datové vrstvy patří:

\myparagraph{DAOs}
DAOs jsou zodpovědné za přímý přístup k datovým úložištím a provádění operací jako čtení, zápis, aktualizace a mazání dat. Tyto objekty 
poskytují abstrakci nad konkrétními technologiemi datových úložišť a umožňují snadnou změnu úložišť bez vlivu na ostatní části aplikace.

\myparagraph{DTOs}
DTOs jsou objekty používané k přenosu dat mezi vrstvami aplikace. Tyto objekty slouží k přenosu dat mezi datovou vrstvou a doménovou 
vrstvou a často mapují datové entity na jednodušší objekty nebo struktury pro snadnější manipulaci.

\myparagraph{Datové entity}
Datové entity představují strukturu a schéma dat uložených v databázi nebo jiném datovém úložišti. Tyto entity obvykle přímo odrážejí
strukturu tabulek v relační databázi nebo dokumentů v NoSQL databázi a poskytují model, se kterým mohou pracovat ostatní vrstvy aplikace.

\myparagraph{Datová úložiště}
Datové úložiště jsou fyzická místa, kde jsou data uložena. Mohou to být relační databáze, NoSQL databáze, soubory na disku nebo externí API. 
Datová vrstva zajišťuje, aby bylo možné efektivně pracovat s těmito úložišti a aby byla data bezpečně uložena a získána.

\bigskip

Tyto vrstvy jsou spolu propojeny následujícím způsobem.

\begin{figure}[H]
  \centering
  \includegraphics[width=.8\textwidth]{arch_diagram.png}
  \caption{Provázanost jednotlivých částí datové vrstvy}
  \label{fig:arch_diagram}
\end{figure}

\bigskip

Po shrnutí dosavadně zmíněních poznatků týkajících se architektury aplikace byly jednotlivé vrstvy převedeny do jednotlivých balíků s následující
strukturou:

\dirtree{%
.1 data\DTcomment{datová vrstva}.
  .2 model\DTcomment{}.
  .2 repository.
.1 ui\DTcomment{prezentační vrstva}.
  .2 composables\DTcomment{}.
  .2 screens\DTcomment{}.
    .3 HomeScreen\DTcomment{}.
}
\bigskip



% \dirtree{%
%         .1 src \DTcomment{}.
%           .2 androidMain \DTcomment{}.
%           .2 commonMain \DTcomment{je pro kód sdílený mezi všemi platformami}.
%             .3 kotlin \DTcomment{}.
%               .4 data\DTcomment{datová vrstva}.
% 		            .5 model\DTcomment{}.
% 		            .5 repository.
% 		          .4 ui\DTcomment{prezentační vrstva}.
% 		            .5 composables\DTcomment{}.
% 		            .5 screens\DTcomment{}.
% 		              .6 HomeScreen\DTcomment{}.
%             .3 resourses \DTcomment{}.
%           .2 desktop Main \DTcomment{}.
% 	}


% \begin{figure}[H]
%   \centering
%   \includegraphics[width=1\textwidth]{mvvm.png}
%   \caption{MVVM with Clean Architecture}
%   \label{fig:mvvm}
% \end{figure}

\section{Návrh UI}
UI bylo navrhováno tak aby vyhovovalo 

v Android dokumentaci jejíž části se zaměřují na návrh od jednotlivých tlačítek, textů až po to jak celé UI posobí z poheledu
uspořádání.



TODO pravidla stravneho navrhu UI

\section{Tvorba drátových modelů}
K tomu aby bylo výsledné UI pro uživatele přívětivé bylo přístupováno tak aby co nejvíce  s pravidly dobrého návhu UI.

Mezi takoví pravidla patří:
TODO

Navržené drátové modely byly vytvořeny na základě funkčních požadavků a to tak, aby nejdůležitější a nejčastěji používané funkce byly 
umístněny na domovkou obrazovku. A zbylé méně podstatbé nebo prostorově náročnější byli umístěny na sekundární obrazovky.

Zároveň byla snaha o 

\pagebreak
\begin{minipage}[t]{0.45\textwidth}
  \myparagraph{Domovská obrazovka}
  Jak již bylo zmíněno v úvodu této kapitoli, tak domovská obrazovka obsahuje většinu nejdůležitější a 
  
  Na základně...byla pro události vybrána možnost zobrazení jednotlivých událostí v posuvném řádku a to především díky možnosti zobrazit
  veškeré potřebné události kompaktně na malém prostoru, ale přesto uživateli nabídne možnost danou událost rozkliknout a dohledat zbylé informace.
  Z ... \ref{} totiž vyplivá, že akce poutají především svým vizuálním největší část informace je uživateli předána právě pomocí titulního obrázku, názvu
  a času konání.
  
  Oproti tomu pro seznam novinek ve spodní části obrazovky bylo vybráno uspořádání novinek do posuvného sloupce, který lépe umožňuje 
  vyžít celou šíři obrazovky k zobrazení delších titulků a textů událostí, které jsou pro uživatele v případě aktualit nejdůležitější.
  
  Mezi další UI prvky na domovské obrazovce patří tlačítka v její horní části, která uživateli umožňují rychlý proklik na YouTube kanál města,
  nahlášení závady, zobrazení uředních hodin a kontaktů.
  
  %V horní části se nachzí sekce umožňující přidání vlastní 
  
  %další čast obrazovky je věnována popolárním udáslostem, které jsou vybráná na základě ...
  
  \bigskip
  \myparagraph{Obrazovka událostí}  
  V rámci obrazovky "Události" je použit stejný systém pro zobrazené údálostí pomocí skrolovaního řádku jako je tomu na domovské obrazovce.
  
  Oproti domovské stránce jsou zde však zobrazeny veškeré události, které se ve městě budou konat. Pro lepší přehled jsou udáslosti rozděleny 
  do několika málo kategorií.
  
  V hoorní části aplikce je uživateli dána možnost vybrat den pro který chce zobrazit plánované udáslosti, případně zvolit požadované rozmezí.
  
  %jako například Kino, Divadlo, Celodenní akce, akce pro děti, přednášku atd.
  
  
  Byla navžena tak aby uživatelé mohli jednoduše filtrovat zobrazované události přmárně podle času.
  
  filtrování podle kategorie bylo nejprve navrženo ale následně z neho bylo umuštěno kvůli malému počtu kategorií.
  
  byl zvolen přístup, který vybrané události přiřadí do patřičné kategorie a zobrzí jen ty kategorie, které obsahují alespoň jednu událost.
  
  veškeré kategori se zobrzí na maximalně 3 straánkách což se ukázalo
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\textwidth}
  \begin{figure}[H]
    \centering
    \includegraphics[width=.7\textwidth]{home_wireframe.png}
    \caption{Wireframe obrazovky \textit{Domů}}
    \label{fig:wireframe1}
  \end{figure}
  \begin{figure}[H]
    \centering
    \includegraphics[width=.7\textwidth]{events_wireframe.png}
    \caption{Obrazovka \textit{Více}}
    \label{fig:wireframe2}
  \end{figure}
\end{minipage}

\begin{minipage}[t]{0.45\textwidth}
\myparagraph{Obrazovka parkování}
Obrazovká parkovaní slouží uživateli především k vyhledání parkovací zóny, získání informací o ceně parkování případně k platbě parkovného.

Aby bylo docíleno co nejjednuším manipulace s mapovými podklady byl prostor obrazovky navržen tak aby hlavní část byla věnována přávě mapovému
podkalu na němž jsou vyznačeny parkovancí zóny. 

Pro usnadnění hledání parkovacích zón dává aplikace uživateli možnost vyhlenání požadovaná parkovací zóny pomocí vyhledávací pole, které 
uživateli umožňujě vyhledat příslušnou parkovancí zónu buďto podle čísla nebo názvu zóny. 

Dále zde byla implentována výsuvná karta ze spodní části obrazovky, která se zobrazí pouze v případě, že uživatel vyberere nějakou
z nabízených parkovacích zón. Nezmenšuje tak uživateli prostor pro rychlé vyhledání parkovanící zóny, které je hlavním cílem k použití této obrazovky. 

Tato výsuvná karta uživateli zobrazí detailní informace k vybrané parkovancí zoně a dá uživateli možnost zaplatit parkovné.

Poslední funkci, kterou tato obrazovka nabízí je zobrazení aktuálního provozu ve městě. 


\bigskip
\myparagraph{Obrazovka více}
Poslední navrženou obrazovkou je obrazovka "Více", která obsahuje přehled veškerých funkcí aplikace a zároveň obsahuje veškeré méně podstatné 
časti aplikace.

Jelikož je ale aplikce cílena pro široké spektrum lidí, byl zde navžena funkce, která umožnuje přidání vybraného prvku na domovskou obrazovku.


který uživatelům umožňuje přízpůsobení domovské obrazovky.
při dlouhém stisknnutí zobrazí možnost přidání prvku na domovskou obrazovku.
které mohou být přidány na uvodní obrzovku.


v případě, že by uživatel shledal některou 
z nabízených funkcí důležitější/častěji potřebnou, tak umožňnuje uživateli tuto funkci přidat na domovskou obrazovku.

Představuje rychlo naviga

Obsahuj důležité prvky aplice, které obsahují veškeré méně podstatné časti aplikace.
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\textwidth}
  \begin{figure}[H]
    \centering
    \includegraphics[width=.7\textwidth]{parking_wireframe.png}
    \caption{Wireframe obrazovky \textit{Parkování}}
    \label{fig:wireframe3}
  \end{figure}
  \begin{figure}[H]
    \centering
    \includegraphics[width=.7\textwidth]{more_wireframe.png}
    \caption{Wireframe obrazovka \textit{Více}}
    \label{fig:wireframe4}
  \end{figure}
\end{minipage}

\section{Návrh design systému} \label{designSystemSection}
Před tím něž bylo přistoupeno ke grafickému návrhu aplikace, tak byl vytvořen obecný design systém, který poslouží k vytvoření 
konzistentního uživatelského rozhraní. Zároveň se díky němu urychlí proces navrhovaní grafické podoby UI a při následné fázi implementace 
zajistí intuitivní ovládání aplikace na všech platformách. 

%Design system je obecně vzato sada komponent, pravidel, principů a návrhových postupů, které slouží k vytváření konzistentního
%uživatelského rozhraní a uživatelského zážitku napříč různými aplikacemi a platformami. 

Design systém je obecně vzato sada předem definovaných pravidel, komponent, standardů a návrhových principů, které slouží k vytváření a udržování 
konzistentního a jednotného vizuálního stylu v rámci celé aplikce. Takový systém tak zahrnuje různé prvky jako jsou barvy, typografie, ikony,
layouty a komponenty uživatelského rozhraní a umožňuje vývojářům a designérům efektivně spolupracovat a vytvářet aplikace s jednotným 
vzhledem. 
 
Cílem návrhu design systému je zajistit, aby všechny části aplikace měly jednotný vzhled a chování, což zlepšuje předvším uživatelskou 
zkušenost s implementovanou aplikací. 
%Designový systém zároveň často obsahuje sadu prvků UI, typografického stylu, barev, ikon a další informace, které 
%pomáhají designérům a vývojářům při tvorbě aplikací.

%V navrhovaní výslednéh design systému bylo přistupováno tak aby styl navržených UI komoponenty, typů písma, barem a dalších prvků design 
%systému přiblině odpovídal aktuálně používanému stylu města.

%Jelikož město, které bylo vybráno pro implementaci aplikace nikde expliciteně nedefinovalo používaný design systém,
%byl proto vytvořen na základě. 
%TODO NEBO 

V rámci vybraného města Příbrami není takový systém nikde expliciteně zadefinovaný a proto byl odvozen z designu webových stránek města.
pro navození maximálního pocitu jednoty s dosavadními informačními systémy města.

Zároveň byl zkobinovaný s aktuálně nejnovějším design systémem od společnosti Google zvaným Material 3, který se hodí nejen pro použití
na mobilních platformách.

S ohledem na to, že aplikce je navrhována pro použití na mobilních zařízením, tak je tomu uzpůsoben i návrh samotné design systému, který
specifikuje především prvky použitelné na mobilních platformách a zbylé části mohou být případně v budoucnu rozšířený o další prvky 
používané na jiných platformách.

V tomto případě bylo navrženo pár základních UI prvků, které budou použity v rámci této aplikace a mouhou být použity i případně dalšími 
aplikací města.

Výsledek základní ukázky takto navrženého systému je k vidění na obrázku \ref{fig:design_system}

\begin{figure}[H]
  \centering
  \includegraphics[width=.99\textwidth]{design_system.jpg}
  \caption{Vytvořený design systém}
  \label{fig:design_system}
\end{figure}

\section{Návrh mockup modelu} \label{navrhMockupModelu}
Po zadefinování použitelných komponet v navženém design systému \ref{designSystemSection} jež samotný návrh grafické podoby UI zjednodušen 
na nezbytné minimum. 

Vytvořené mockup modely jsou defacto výsledkem sloučení dratových modelů s navrženým design systémem.

při návrhu grafické podoby UI byla proto priparně soustředěn na vyznam jedlotlivých UI komponent a na základě jejich významu byla
přiřazovány odpovídající barvy. 

Navržené UI se snaží respektovat zásady správného UI návrhu dle Android dokumentace a to především z pohledu přístupnosti, rozložení obsahu, 
druhu použití UI komponent nebo vhodnosti použití barev.

%\pagebreak
\begin{minipage}[t]{0.45\textwidth}

\bigskip
\myparagraph{Přístupnoust}
Z pohledu přístupnosti je UI aplikace navrženo tak, aby jednotlivé prvky UI měli vhodně zvolenou barvu z poheledu
správného kontrasku vůči podkladu a nebo z pohledu dostatečné čitelnosti.

Dále byla věnována pozornost správnénumu popisu jedlotlivých UI komponent tak, aby bylo možné aplikaci používat i s tazvanou TalkBack čtečkou, která 
umožňuje nevidomím nebo jinak zrakově postiženým lidem používat aplikaci.

\bigskip
\myparagraph{Barvy}
I přesto, že základní barvy byly zvoleny již v při navrhování designu systému, tak během faze návhu mockup modelu byl zároveň kladen důraz na  jejich 
vhodné použít z pohledu sémantiky barev nebo důležitosti barvených komponenta.

V základu \textit{Material Theme Builder} umožnuje definovat 3 základní barvy (primárním, sekundárním, ternární), kterém máji jasně vymezené role.
a ta v případě implementovaného UI byla použita například pro potvzovancí akci "zplacení parkovného". Senkundární barva byla
implementována například na filtrační talčítka na obrazovce "Události", jelikož hlavním předmětem pozornosti v daném zobraní 
jsou zobrazované akce a ne filtrační možnosti.

\bigskip

\myparagraph{Rozložení}
Co se týká rozložení UI komponent na obrazovky, tak zde bylo respektorváno pár pravidel liniového zarovnání, tak aby nechozázelo
k narušení čitelnosti.

Komponety pro důležité interakce byly drženy v takzvané dosahové vzdálenosti jako primarní navigace nebo tlačítka pro vykonání
důležitých akcí.

Pro obrázky byly voleny bězné poměry jako například 4:3, tak aby nedocházelo k jejich zbytéčnému ořezávání.

Zároveň 

 Sytost barev byla zvolena na základě
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\textwidth}
  \begin{figure}[H]
    \centering
    \includegraphics[width=.6\textwidth]{screen1.png}
    \caption{Obrazovka \textit{Domů}}
    \label{fig:mockup1}
  \end{figure}
  \begin{figure}[H]
    \centering
    \includegraphics[width=.6\textwidth]{screen2.png}
    \caption{Obrazovka \textit{Události}}
    \label{fig:mockup2}
  \end{figure}
\end{minipage}

\pagebreak

\begin{minipage}[t]{0.45\textwidth}
  TEXT DRUHE STANKY
  \lipsum[1]
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\textwidth}
  \begin{figure}[H]
    \centering
    \includegraphics[width=.6\textwidth]{screen3.png}
    \caption{Obrazovka \textit{Parkování}}
    \label{fig:mockup3}
  \end{figure}
  \begin{figure}[H]
    \centering
    \includegraphics[width=.6\textwidth]{screen4.png}
    \caption{Obrazovka \textit{Více}}
    \label{fig:mockup4}
  \end{figure}
\end{minipage}

\chapter{Implementace}
Stejně tak jako v případě vývoje Android aplikací, tak k sestavování multipaltformích aplikací založených na Compose Multiplatform 
se používá nástroj zvaný Gradle.  

\section{Gradle} \label{gradleChapter}
Gradle je open-source nástroj pro automatizaci sestavení a správu závislostí při vývoji softwaru. Je to nástroj pro automatizaci sestavení 
podobný Antu nebo Mavenu, který byl vyvinut pro zjednodušení procesu sestavení a nasazení softwaru.

Gradle používá deklarativní doménově specifické jazyky (DSL), díky kterým umožňuje definovat sestavení a konfiguraci projektu pomocí srozumitelné
a flexibilní syntaxe. Od verze 3.0 z roku 2016 je možné psát Gradle skripty v jazyce Kotlin DSL a od roku 2023 je Kotlin DSL primarním jazykem 
pro jejich zápis. To umožňuje vývojářům snadno konfigurovat sestavení a spravovat závislosti na knihovnách a modulech v jazyku se stejnou
syntaxí jako je používána pro ostatní části projektu.

%K vytvoření projektu založeném na Compose Multiplatform je doporučeno využití právě totoho sestavovacího nástoroje. 

K tomu aby bylo možné Compose Multiplatform v projektu použít, je zapotřebí do projektového souboru \code{build.gradle.kts} přidat Compose 
Multiplatform plugin (viz výpis kódu \ref{lst:ComposePlugin}).

\begin{lstlisting}[caption={Integrace Compose Multiplatform pluginu do sestavovacího scriptu}, label={lst:ComposePlugin}, language=Kotlin]
plugins {
  id("org.jetbrains.compose") version "1.6.0"
}
\end{lstlisting}

Dále je zapotřebí vybrat platformy pro které má být aplikace určena a podle nich vytvořit příslušné balíčky viz kapitola \ref{projectStructure}.
V připadě implemetované aplikace se jedná o platformy Android a iOS, které bylo nutné specifikovat v projektovém souboru 
\code{build.gradle.kts} (viz řádky 2 - 30 na výpisu kódu \ref{lst:LibIntegration}).
Podle těchto platforem lze následně v příslušném \code{build.gradle.kts} vytvořit takzvané \code{sourceSets}, díky kterým je možné
pro každou platformu implementovat platformě specifické závislosti. Tyto závislosti se následně vkládají do příslušných
sourceSets podle toho, zdali se jedna o multiplatformní (\code{commonMain}) nebo nativní závislost (\code{androidMain}, \code{iosMain}, atd.).

Pro ukázku jak taková multiplatformní závislost může vypadat slouží řádky 32 - 37 na ukázce kódu \ref{lst:LibIntegration}, pomocí 
kterých je do projektu přidána knihovna umožnující implementaci multiplatformní navigace.

\begin{lstlisting}[caption={Lib integration}, label={lst:LibIntegration}, language=Kotlin]
  kotlin {
    androidTarget {
        compilations.all {
            kotlinOptions {
                jvmTarget = "11"
            }
        }
        @OptIn(ExperimentalKotlinGradlePluginApi::class)
        instrumentedTestVariant {
            sourceSetTree.set(KotlinSourceSetTree.test)

            dependencies {
                implementation("androidx.compose.ui:ui-test-junit4-android:1.6.4")
                debugImplementation("androidx.compose.ui:ui-test-manifest:1.6.4")
            }
        }
    }

    jvm("desktop")

    listOf(
        iosX64(),
        iosArm64(),
        iosSimulatorArm64()
    ).forEach { iosTarget ->
        iosTarget.binaries.framework {
            baseName = "ComposeApp"
            isStatic = true
        }
    }

    sourceSets {
      commonMain.dependencies {
        implementation(libs.voyager.navigator)
        ...
      }
    }
  }
\end{lstlisting}

Dále je potřeba do spouštěcích souborů každé platformy integrovat multiplatformní část aplikace, která může být do nativního kódu přidána
například pomocí \textit{Composable} funkce, která je napsána v rámci sdílené části aplikace.

Ve výpisu kódu \ref{lst:SharedIntegration} je touto funkcí funkce \code{App()}, která je volána z nativního Android kódu a stará se
o deklaraci veškerého multiplatformního UI.

\begin{lstlisting}[caption={Lib integration}, label={lst:SharedIntegration}, language=Kotlin]
class MainActivity : ComponentActivity() {

  override fun onCreate(savedInstanceState: Bundle?) {
      super.onCreate(savedInstanceState)

      setContent {
          App()
      }
  }
}
\end{lstlisting}

Stejným způsobem je potřeba integrovat tuto funkci i do ostatních spouštěcích souborů. 



Jelikož časem projekt obsahuje je vhodné pro správu verzí použít takzvaný version katalog. 

\myparagraph{Gradle version catalog}
Gradle version catalog je obyčejní soubor ve formátu TOML, který umožňuje snadněji přidávat a spravovat závislosti a pluginy ve celém projektu. 
Místo ručního přidávání závislostí a pluginů do každého modulu zvlášť je možné shromáždit veškeré závisloti v tomto souboru a zadefinovat rovněž
verzi, která má být pro tento modul použita napříč celým projektem. 

Příklad toho jak mohou být dříve zmíněné závislosti přepsány do version
katalogu je uveden ve výpisu kódu \ref{lst:VersionCalalog}.

\begin{lstlisting}[caption={Version katalog}, label={lst:VersionCalalog}, language=Kotlin]
[versions]
compose-plugin = "1.6.0"
voyagerVersion = "1.0.0"

[libraries]
voyager-navigator = { module = "cafe.adriel.voyager:voyager-navigator", 
                      version.ref = "voyagerVersion" }
[plugins]
jetbrainsCompose = { id = "org.jetbrains.compose",
                     version.ref = "compose-plugin" }

\end{lstlisting}

\section{Tvorba UI obecně}
\subsection{Navigace}
Navigace je klíčovou součástí moderních aplikací uživatelského rozhraní, která uživatelům umožňuje pohybovat se mezi různými obrazovkami či 
částmi aplikace. Hlavním cílem navigace je poskytnout uživatelům intuitivní a plynulý způsob průchodu obsahu a provádění akcí v aplikaci. 

Aktuálně však komponenta navizage ze sady knihoven Jetpack Compose není k dispozici a proto je potřeba zvolit nějakou alternativu poskytovanou
třetí stranou. \cite{composeNav} Výčet aktuálně doporučených knihoven pro implementaci multipaltformí navigace je uveden v oficiálních Kotlin 
multiplatform dokumentaci a zahrnuje navigace Voyager, Decompose nebo Appyx. K implemnaci byl po zvážení nakonec vybrána navigace Voyager a 
to především díky přehledné dokumentaci, intuitivní implementaci a jednoduchému principu navigace založeném na zásobníku, který pro aktuálně
implementovanou aplikaci plně dostačuje.

V budoucu by však měla být dostupná, ale do té doby je potřeba vybrat z alternativních knihoven.



%\section{Navigace a lokalizace v implementaci}
\subsection{Implementace design systému}

Při implementace design systému pomocí Compose Multiplatfom byla snaha co nejpřesněji napodobit navržený design sytém z kapitoly \ref{designSystemSection}
tak aby uživateli navodil maximalní pocitu jednoty s dosavadními informačními systémy města.


Compose multiplatform je přípraven na implementaci design systému. 

loading


\subsubsection{Barvy} \label{colorSection}
Barvy byly zvoleny na základě navženého design systému, který byl navžen na základě vizuálního stylu města, které město 
Příbram využívá při všech prezentačních příležitostech.

Pro použití výbraných barev v aplikaci bylo zapotřebý jednotlivé barvy zadefinovat následujícím způsobem:

\begin{lstlisting}[caption={Zadefinování barev}, label={lst:ComposeCode}, language=Kotlin]
  val md_theme_light_primary = Color(0xFFBC004C)
  val md_theme_light_onPrimary = Color(0xFFFFFFFF)
  val md_theme_light_primaryContainer = Color(0xFFFFD9DE)
  val md_theme_light_onPrimaryContainer = Color(0xFF400015)
  ...

  val md_theme_dark_primary = Color(0xFFFFB2BE)
  val md_theme_dark_onPrimary = Color(0xFF660026)
  val md_theme_dark_primaryContainer = Color(0xFF900039)
  val md_theme_dark_onPrimaryContainer = Color(0xFFFFD9DE)
  ...
\end{lstlisting}

Takto zadefinované barvy je následně možné použít napříč aplikací k obarvení tlačítek, textů, ploch atd.

Mimojiné jsou taktéž použity pro definování barevných motivů, které se definují následujícím způsobem:

\begin{lstlisting}[caption={Definice barevných motivů}, label={lst:ComposeCode}, language=Kotlin]
  private val LightColors = lightColorScheme(
    primary = md_theme_light_primary,
    onPrimary = md_theme_light_onPrimary,
    primaryContainer = md_theme_light_primaryContainer,
    onPrimaryContainer = md_theme_light_onPrimaryContainer,
    secondary = md_theme_light_secondary,
    ...
  )

  private val DarkColors = darkColorScheme(
    primary = md_theme_dark_primary,
    onPrimary = md_theme_dark_onPrimary,
    primaryContainer = md_theme_dark_primaryContainer,
    ...
  )
\end{lstlisting}

Díky takto zadefinovaným motivům je následně možné obarvit veškeré komponenty aplikace podle aktuálně použivaného režimu.

\begin{lstlisting}[caption={Definice barevných motivů}, label={lst:colorsDef}, language=Kotlin]
  @Composable
  fun AppTheme(
    useDarkTheme: Boolean = isSystemInDarkTheme(),
    content: @Composable() () -> Unit
  ) {
    val colors = if (!useDarkTheme) {
      LightColors
    } else {
      DarkColors
    }
  
    MaterialTheme(
      colorScheme = colors,
      content = content
    )
  }
\end{lstlisting}

\subsubsection{Typografie}
je používána k definování stylu písma. Využívá k tomu styly definované Material designem. ten definuje celkem 15 druhů písma,
kde každé z nich má definovaný způsob použití. \cite{material3} Jelikož se jedná o výchozí styly písma, tak lze k těmto stylům přistupovat přes
Composable funkci \code{MaterialTheme} popsanou v kódu \ref{lst:colorsDef} aniž by se parametr \code{typography} musel explicitně
uvádět.

\begin{lstlisting}[caption={Ukázka použití stylu písma}, label={lst:typographyExample}, language=Kotlin]
  Text(
    text = news.title,
    style = MaterialTheme.typography.headlineMedium
  )
\end{lstlisting}

\section{Použité technologie}
Následující podkapitola je věnována konkrétním technologiím, které byli pro tvorku komponent z předchozí kapitoli použity.

\subsection{Kotlin}
\subsection{Coroutines}
\subsection{Ktor}
Ktor je open-source framework vytvořený společností JetBrains pro tvorbu aplikací jak na serverové tak i klientské části pomocí programovacího 
jazyka Kotlin.

Ktor byl vyžit především kvůli tomu, že obsahuje multiplatformního asynchronního HTTP klienta pomocí kterého je možné zadávat HTTP požadavky a 
zpracovávat odpovědi. 

\begin{lstlisting}[caption={Definice barevných motivů}, label={lst:colorsDef}, language=Kotlin]
private val client = HttpClient {
  install(HttpTimeout) {
      requestTimeoutMillis = 40000
  }
}

suspend fun getEventsXml(): EventsXmlDto {
    val response: String = client.get("https://kalendar.pribram.eu/...").body()
    return format.decodeFromString<EventsXmlDto>(response.cleanUpEventXml())
}
\end{lstlisting}

\subsection{Voyager}
Voyager je multiplatformní navigační knihovna, která umožňuje navigovat mezi různými obrazovkami a destinacemi v multiplatformních mobilních
 aplikacích. \cite{voyager} Jeho hlavním cílem je poskytnout jednotné rozhraní pro navigaci v různých mobilních platformách, jako jsou Android a iOS, a 
 zároveň maximalizovat sdílený kód a snižovat duplikaci kódu.

 V rámci implementované aplikace byla Voyager navigace použita k implementaci základní navigace mezi jedlotlivými obrazovkami.
 Příkladem takové navigace jsou veškeré možné přechody v rámci domovské obrazovky. Tato navigace vyžívá ke své funkci takzvané 
 \textit{Stack API}, které jehož implementace fungguje na principu zásobníku. S tím, že pokud uživatel vstoupi na navou obrázovku 
 (například přejde na stranku zobrazující detail vybrané udásloti), tak je do tohoto zásobníku přidán odkaz na takzvaný SnapshotState,
 který uchává stav právě opuštěné obrazovky a je znovu obnoven v případě, že se uživatel na tuto obrazovku znovu vrátí. Zároveň tento
 zásobník slouží k tomu, aby navigace vždy věděla na jakou stránku se má vrátit (poslední v zásobníku), když uživatel provede akci zpět
 například pomocí tlačítka zpět na platformě Android. \textit{Stack API} zároveň umožnuje použití několika funkcí jako jsou například 
 \code{push}, \code{replace}, \code{replaceAll} používané pro průchod vpřed nebo funkce \code{pop}, \code{popAll}, \code{popUntil}
  pro zpětný návrat. 

 Díky této implementaci je možné používané obrazovky do sebe libovolně zanořovat a v případě, že je potřeba nějakým způsobem upravit
 stav předchozích TODO

 Nicméně tento způsob navigace není vhodné použít pro navigaci mezi jednotlivými záložkami aplikace (lišta ve spodní části displaye) 
 a proto je tado část navigace 
 implementována pomocí takzvané \textit{Tab navigation}, kterou knihovna Voyager, taktéž poskytuje. V přípaně použití záložek se
 průchod nezapisuje do zásobníku jako v předchozím případě jelikož jednotlivé záložky jsou na stejné urovní a implementace navigace
 založené na zásobníku by byla pro uživatele matoucí.

 TODO
 \begin{lstlisting}[caption={Ukázka použití navigace založené na záložkách}, label={lst:tabNav}, language=Kotlin]
TabNavigator(
  tab = HomeTab
) {
    Scaffold(
        modifier = Modifier.fillMaxSize(),
        bottomBar = {
            BottomNavigation(
                backgroundColor = MaterialTheme.colorScheme.background
            ) {
                TabNavigationItem(HomeTab)
                TabNavigationItem(EventsTab)
                TabNavigationItem(ParkingTab)
                TabNavigationItem(MoreTab)
            }
        },
        content = { CurrentTab() },
    )
}
\end{lstlisting}

\subsection{Koin}
Koin je moderní knihovna pro správu závislostí v aplikacích napsaných v jazyce Kotlin. Jedná se o lehkou a snadno použitelnou alternativu 
k jiným známým knihovnám, jako je například Dagger. Koin se zaměřuje na jednoduchost použití a minimalismus, což usnadňuje vývoj aplikací 
a zároveň zlepšuje čitelnost a údržbu kódu.

Hlavním principem Koinu je deklarativní přístup k definici závislostí pomocí tzv. modulů. V modulu se specifikují všechny závislosti a 
jejich vytváření, a to pomocí jednoduchých funkcí nebo tzv. singletons. Tento přístup umožňuje snadnou konfiguraci závislostí a poskytuje
 vývojářům transparentní pohled na strukturu aplikace.

\bigskip

V rámci této aplikace byl Koin použit například pro vložení databázového ovladače za pomocí expect actual deklarace \ref{expectActual}.
Využití tohoto zápisu bylo vhodné použít především díky tomu, že převážná většitna databázové logiky je napsána v rámci sdílené 
logiky a v rámci nativní logiky, byl tak implementovám pouze databázový ovladač.

\begin{lstlisting}[caption={DI databázového ovladače pomocí Koinu}, label={lst:KoinInit}, language=Kotlin]
class MainActivity : ComponentActivity() {

  private val dbDriverFactoryModule = module {
      single { DatabaseDriverFactory(applicationContext) }
  }

  init {
      loadKoinModules(dbDriverFactoryModule)
  }
  ...
}
\end{lstlisting}

\subsection{SQLDelight}
SQLDelight je multiplatformní knihovna pro práci s relačními databázemi v aplikacích napsaných v jazyce Kotlin. Jedná se o moderní nástroj, 
který umožňuje vytváření a správu SQL dotazů pomocí typově bezpečných prostředků poskytovaných jazykem Kotlin.

Hlavní funkcionalitou SQLDelightu je automatická generace Kotlinových tříd na základě definovaných SQL schémat. To znamená, že vývojáři
 mohou psát SQL dotazy pomocí standardní SQL syntaxe a SQLDelight se postará o vygenerování příslušných tříd v jazyce Kotlin, které umožňují 
 snadný a bezpečný přístup k databázi. Jediným rozdílem oproti standardním SQL dotazům je označení jednotlivých SQL dotazů takzvaným 
 štítkem (viz "selectAllNews:" ve výpisu kódu \ref{SQLDotaz}) pomocí kterého je vygenerována příslušná Kotlin funkce. 

\begin{lstlisting}[caption={SQL dotaz}, label={lst:SQLDotaz}, language=SQL]
selectNewsById:
SELECT *
FROM News
WHERE id = :id;
\end{lstlisting}

Vygenerové metody (dotazy) lze následně nalézt ve složce \code{} a pro výše uvedený dotaz vypadá takto

\begin{lstlisting}[caption={SQL vygenerovaný dotaz}, label={lst:SQLGeneratedDotaz}, language=SQL]
private inner class SelectNewsByIdQuery<out T : Any>(
  public val id: Long,
  mapper: (SqlCursor) -> T,
) : Query<T>(mapper) {
    override fun addListener(listener: Query.Listener) {
    driver.addListener("News", listener = listener)
  } TODO
  \end{lstlisting}
  

SQLDelight také nabízí silnou typovou kontrolu při práci s daty v databázi. To znamená, že chyby v SQL dotazech jsou odhaleny již při
 kompilaci kódu, což usnadňuje odhalování chyb a zvyšuje stabilitu aplikace.

I přesto, že většina kódu může být psána v balíčku sdílenem mezi všemi platformami, je zde i část z předchozí ukázky \ref{lst:SQLGeneratedDotaz}
, kterou je potřeba naimplementovat nativně. Konkrétně se jedná o ovladače k jejichž implementaci jsou potřeba nativní knihovny a musí
být proto implementovány v balíčcích jednotlivých platforem. Pro 

TODO
\begin{lstlisting}[caption={SQL vygenerovaný dotaz}, label={lst:SQLGeneratedDotaz}, language=SQL]
  actual class DatabaseDriverFactory {
    actual fun createDriver(): SqlDriver {
        //val driver: SqlDriver = JdbcSqliteDriver("jdbc:sqlite:test.db")
        val driver: SqlDriver = JdbcSqliteDriver(JdbcSqliteDriver.IN_MEMORY)
        AppDatabase.Schema.create(driver)
        return driver
    }
}
\end{lstlisting}


%\subsection{Full text search impl tech} \label{fulltextSearch}
%TODO
% neco na fulltextové vyhledavani


\subsection{Coil}
Coil je knihovna pro načítání a zobrazování obrázků v aplikacích pro Android, napsaná v jazyce Kotlin. Jedná se o moderní a jednoduché 
řešení pro práci s obrázky, které nabízí rychlost, efektivitu a snadnou integraci. Knihovna poskytuje jednoduché API pro načítání obrázků 
z různých zdrojů, včetně URL adres, souborů a zdrojů z paměti. Díky tomu je integrace obrázků do aplikace snadná a přizpůsobitelná potřebám projektu.

Coil nabízí automatické dohledávání velikosti obrázků na základě rozměrů zobrazení, což pomáhá optimalizovat paměť a výkon aplikace. Tato funkce 
umožňuje načítat obrázky ve správné velikosti a snižuje zátěž na síťové spojení. Knihovna podporuje širokou škálu formátů obrázků, včetně PNG, 
JPEG, GIF, SVG a WebP, což umožňuje pracovat s různými typy obrázků bez nutnosti dalšího přizpůsobování.

Další výhodou Coil je možnost efektivního cachování obrázků, což pomáhá snižovat čas načítání a zlepšuje uživatelský zážitek. Knihovna je navržena tak, 
aby se snadno integrovala s moderními architekturami aplikací, jako je například Android Jetpack a architektura MVVM. To umožňuje vývojářům využívat 
přednosti moderních technologií a frameworků při práci s obrázky.

TODO uvest coil
\begin{lstlisting}[caption={Coil}, label={lst:Coil3}, language=SQL]
  AsyncImage(
    model = news.thumbnailUri,
    contentDescription = "Sample",
    contentScale = ContentScale.Crop,

    modifier = Modifier.aspectRatio(4f / 3f)
  )
\end{lstlisting}


\section{Implemtace UI vrstvy} \label{UILayerImpl}
V rámci této kapitoly budou ukázáno jakým způsobem byla implementována UI vrstva navržená v kapitole \ref{UILayerNavrh}, j

\subsection{Implementace stavu aplikace} \label{stateHandlingImpl}
Tato kapitola slouží k příblížení toho jak takzvaný \textit{UI State}, kterému byl věnován paragraf \textit{UI state} v 
kapitole \textit{Vrstvy architektury \ref{vrstvyArchitekturySection} } je implemementován v rámci ukázkové aplikace.

Z pohledu UI se jedná o důležitou část aplikace o jejíž aktualizaci se stará již zmíněný ViewModel \ref{ViewModelImpl} neboli ScreenModel v rámci
implementované aplikace. 
Pro zachování stavu jednotlivých obrazek byla použita datová třída, která v sobě umožnujě uchovávat veškeré možné stavy dané obrazovky.
Pro ukázku toho jak byla taková datová třída implementována byla vybrána obrazovka událostí, která v rámci aplikace potřebuje 
uchovávat největsí množství informací (viz \ref{lst:EventState})

\begin{lstlisting}[caption={Event State katalog}, label={lst:EventState}, language=Kotlin]
data class EventsState(
  val events: StateFlow<List<Event>> = MutableStateFlow(emptyList()),
  val selectedFilterOption: FilterOption = FilterOption.TODAY,
  val isDatePickerOpen: Boolean = false,
  val isFetchingEvents: Boolean = false,
  ...
)
\end{lstlisting}

Takto zadefinované stavy mohou být v aplikaci použity například následujícím způsobem. Kde stav udržován 

\begin{lstlisting}[caption={Použití stavu v aplikaci}, label={lst:StateImpl}, language=Kotlin]
  val screenModel = getScreenModel<HomeScreenModel>()
  val state by screenModel.state.collectAsState()

  val news = state.news.collectAsState()
  LazyColumn {
      items(news.value) { news ->
          NewsItem(news = news, onItemClick = {
              navigator.push(NewsDetailScreen(news))
          })
      }
  }
\end{lstlisting}

\subsection{Implementace událostí aplikace} \label{eventHandlingImpl}

V rámci viewModel jsou 



\begin{lstlisting}[caption={Použití stavu v aplikaci}, label={lst:StateImpl}, language=Kotlin]
sealed interface EventsEvent {
  data object OnFilterTodayIsSelected : EventsEvent
  data object OnFilterDateIsSelected : EventsEvent
  ...
}
\end{lstlisting}


\subsection{Implementace ViewModelů} \label{ViewModelImpl}
TODO % odkaz na UI Layer
V rámci implementované aplikace byl pro každou obrazovku implementovám jeden ViewModel, který se stará o logiku každé obrazovky zvlášť. Tato kapitola 
bude proto shrhutím stěžejních částí jednotlichých ViewModelů tak 


V rámci implementované aplikace mají ViewModely jasně definovanou roli a to zpracovávat události přichazející z UI a na jejich základě měnit stav 
aplikace. V tomto duchu jsou implementovany vševhny ViewModely. 



\begin{lstlisting}[caption={Použití stavu v aplikaci}, label={lst:StateImpl}, language=Kotlin]
  fun onEvent(event: EventsEvent) {
    when (event) {
        EventsEvent.OnFilterTodayIsSelected -> {
            screenModelScope.launch {
                val today: LocalDate = Clock.System.todayIn(TimeZone.currentSystemDefault())
                ...

                _state.update {
                    it.copy(
                        selectedFilterOption = FilterOption.TODAY,
                        ...
                    )
                }
            }
        }
    }
  }
\end{lstlisting}

, která ovlivnila implementaci ViewModelů bylo použití navigace Voyager, která poskytuje potřebná rozhraní k 



\section{Tvorba UI obrazovek}
TODO %obecne ukazat jak se UI v compose tvori ze je to daklarativne

Jak již bylo zmíněno v kapitole \textit{Architektura frameworku Compose Multiplatfom \ref{ComposeArch}}, tak k tvorbě UI se v Compose Multiplatform používají 
takzvané Composable funkce, které představují jednotlivé UI prvky zobrazované na obrazovce koncového zařízení. 

Tyto Composable funkce tak mohou představovat jednotlivá tlačítka, texty vstupní pole, seznamy, ale také celé soubory těchto prvků jako jsou 
například celé obrazovky.

Na následujícím výpisu kódu \ref{lst:ConsumeUIState} je proto ukázáno jak mohou být do sebe jednotlivé Composable funkce zanořeny a tím tvoří
takzvaný sémantický strom taktéž popsaný v kapitole \textit{Architektura frameworku Compose Multiplatfom \ref{ComposeArch}}

\begin{lstlisting}[caption={Popis UI widgetů pomocí jazyka Kotlin}, label={lst:ConsumeUIState}, language=Kotlin]
  @Composable
  fun LatestNewsScreen(
      viewModel: NewsViewModel = viewModel()
  ) {
      // Show UI elements based on the viewModel.uiState
  }
\end{lstlisting}

%Zároveň 

%Z těchto Composable funkcí se skládá celé UI


Obsahem následujících podkapitol bude ukázka UI komponent, které byly použity k implementaci navrženého UI.

\subsection{Domovská obrazovka}
Uživatelké rozhraní domovské obrazovky je kompletně implemetováno pomocí Compose Multiplatform a nebylo při jeho implemementaci potřeba
přistoupit k nativímu řešení ani na platformě iOS nebo desktop. 

K tvorbě UI domovské obrazovky bylo nejprve přistupováno na základě vytvořených wireframes a následně stylizováno tak, aby 
jednotlivé komponenty odpovídali navržené podobě UI z kapitoly \ref{navrhMockupModelu}

K implementaci posuvného řádku použitého v kapitole \textit{Tvorba drátových modelů \ref{}} byla použita komponenta zvaná LazyRow.


I implementaci 



LAZY ROW LAZY COLLUMN , OBRAZKY POMOCI COIL, STYLOVANI POMOCI DESIGN SYTEMU, VYUZITI DATABAZE, ukazka Event lazy row komoponenty

Obě tyto komponent navíc nabízí postupné načítání jejich obsahu, což nezpomaluje načítání obsahu v případně většího množství novinek
nebo událostí.

\begin{lstlisting}[caption={Coil}, label={lst:Coil3}, language=Kotlin]
  @Composable
  fun EventLazyRow(category: EventCategory, state: EventsState) {
      val scrollState = rememberLazyListState()
      val coroutineScope = rememberCoroutineScope()
      val navigator: Navigator = LocalNavigator.currentOrThrow
  
      Column {
          Text( ... )
          LazyRow( ... ) 
      {  
        items(eventList) { event ->  //state.filteredEvents
            EventItem(event = event, onItemClick = {
              navigator.push(EventDetailScreen(event))
            })
          }
        }
      }
  }
\end{lstlisting}

\subsection{Obrazovka \textit{Události}}

V rámci obrazovky "Události" je používána stejná komponanta pro zobrazování událostí jako byla použita na domovská obrazovce. 

pro zobrazené údálostí "EventLazyRow". 

Každý z nich obsahuje udásti z jedné katregorie. Ty jsou předem přípraveny ViewModele, který při zavolaní nějaké z filtrovacích
událostí nejprve vybere události, které spadají do vymezeného časového intervalu a následně u nich zjistí do jakých kategorií tyto
udásloti patří. Následně pro kažfou katerorii vytvoří jeden LazyRow do kterého umístí příslušné události.

Uživatel má na víběr filrobat události buďto předm zvolených časových rozmezí jako je dnes, zítra nebo může zvolit vlastní 
rozmezí pomocí kiknutí na ikonu kalendáře. Po klidní na ikonu kalendáře se uživateli zobrazí takzvaný DatePicker, který 
uživateli umožnuje zvolit požadované časového rozmezí.

k volbě čacového rozmezí Dnes a Zítra bylu zvoleny takzvané Chips a konkrétně FilterChips, které jsou navrženy k filtrování
a uživatelé jsou na jich použití i z jiných aplikací, které používají Material Design.


LAZY ROW , DATE PICKER, SPECIAL CHIPS


\subsection{Obrazovka \textit{Parkování}} \label{parkingScreenImpl}
K implementaci mapových podkladů bylo zapotřebí použít nativího řešení. 


Bylo využito UI komponenty \code{GoogleMap} z balíčku \code{com.google.maps.android.compose}, která umožňuje vložení mapových podkladů 
na platformě Android.

Dále byla tato obrazovka rozšířena o vyhledávací pole, které uživateli dává možnost jednoduchého vyhledání parkovací zóny podle názvu nebo čísla 
parkovací zóny.

%K tomu je použito fulltextové vyhledání ... popsané v kapitole \ref{fulltextSearch}. 


Dále zde byl na tuté obrazovce implemetován bottom sheet, který je zobrazen pouze v případě, že uživatel vyberere nebo vyhledé pro o jakém 
parkovaní zóně si přeje zobrazit podrobné informace. Díky tomu, že se zobrazí pouze v případě, kdy uživatel požaduje detailnější informace, tak
tento panel nezmenšuje uživateli prostor pro rychlé vyhledání parkovanící zóny v mapě.



\section{Řešení problémů spojených s multiplatformním vývojem}
Nedostatek knihoven
Mezi jeden z hlavních problému patří nedostatek vhodných multiplatformních knihoven a ten se projevil i v případě implementace mapových podkladů
do aplikace kde byla nakonec zvolena implementace nativních mapových podkladů za použití expect a actual deklarací (viz paragraf \ref{expectActual}).

Preview
Další problémem bylo nefunkční náhled UI , což se na výsledném UI nikterak neprojevilo, ale celý proces tvorby UI to značně prodloužilo.

Špatná nebo téměř žádna dokumentace k knihovnám třetích stran a v případě co se týče Compose Multiplatfrom, tak zde je téměř kompletně spoléháno na
identic. 
Na druhou stranu Compose Multiplatform ještě není na všech platformách ve stabilní verzi a proto je možné, že po vydání stabilních verzí i pro jiné
platformy se dokumentace od JetBrains rozříší.


\subsection{Implementace mapových podkladů}

Jak jž bylo zmíněno v kapitole \ref{parkingScreenImpl} tak implementace matových podkladů byla implementována pomocí nativní knihovy proskytovanou
spoůečností Google pro platformu Android. 

\begin{lstlisting}[caption={GoogleMap element}, label={lst:GoogleMapview}, language=kotlin]
  GoogleMap(
    modifier = Modifier.fillMaxSize(),
    properties = MapProperties(
        isTrafficEnabled = true,
        mapType = MapType.NORMAL,
        mapStyleOptions = MapStyleOptions(MapStyle.JSON_LIGHT)
        /*latLngBoundsForCameraTarget = LatLngBounds(
            LatLng(49.7195186,13.9845228)) */
    ),
    cameraPositionState = cameraPositionState
) {...}
\end{lstlisting}

\myparagraph{Impementace motivu mapy}

Aby byla implementace motivů z kapitoly \ref{} komlemtní bylo zapotřebí přizpůsobit i mapove podklady

kreré se mění v závisloti na aktuální motivu zařízení.

\begin{lstlisting}[caption={Motiv mapy ve formátu JSON}, label={lst:MapStyle}, language=kotlin]
  {
    "featureType": "road.highway",
    "elementType": "labels.text.fill",
    "stylers": [
      {
        "color": "#616161"
      }
    ]
  },
  {
    "featureType": "road.local",
    "elementType": "labels.text.fill",
    "stylers": [
      {
        "color": "#9e9e9e"
      }
    ]
  },
\end{lstlisting}


\myparagraph{Získaní a zpracování mapových dat}
Mapová data v podobě seznamu parkovacích zón a jejich podrobnostech jako jsou jednotlivé názvy zón, typy, popisy a umístění zón byla získána od
města Příbrami. 

Poskytnutá data byla získána ve formátu Keyhole Markup Language (KML), který je primárně určen pro publikaci, distribuci geografických dat.
Tento formát ke svému zápisu moužívá sytazi jazyka XML a z toho důvodu byl k jeho převedení do objektů použit stejný XML parser jako při 







\chapter{Testování} \label{testsSection}
Tato kapitola se bude věnovat předvším UI teestování a to z nějkolika růzých pohledů. 

\section{Testování UI}
Od verze 1.6.0 Compse multiplatform umožnuje testování UI na všech platformách. \cite{composeNews1.6.0}

UI testy se používají k ověření, že uživatelské rozhraní aplikace funguje podle očekávání. To zahrnuje testování prvků uživatelského rozhraní, uživatelských 
interakcí a navigačních toků, aby se zajistilo plynulé uživatelské prostředí.

Mezi základní typy UI testl se řadí UI testy testující ktitické uživatelské interakce na jedné obrazovce a dále například navigační testy testující
správnost fungování navigace v dané aplikaci.


\section{Testování výkonu}


\section{Testování kompatibility}
estování aplikace na různých zařízeních s různými velikostmi obrazovek, rozlišeními a hardwarovými konfiguracemi, aby se zajistilo, že funguje 
správně na široké škále zařízení.




\section{Možnosti testování UI v Compose Multiplatform}
Testování aplikací založených na frameworku Compose Multiplatform je stejně tak jako tvorba samotného UI založena na Jetpack Compose a využívá 
proto i stejných konceptů. Mezi tyty klíčové koncepty testovaní UI se řadí následující:


\myparagraph{Testování sémantiky}
V rámci testování
\myparagraph{API rozhraní}
Compose Multiplatform z toto důvodů taktéž využívá tři hlavní principy jak testovat UI, které se v Jetpack compose
označují jako \textit{Finders}, \textit{Assertions} a \textit{Actions}. 
K tomu aby bylo možné UI komponenty testovat se používají funkce, které tyto komponenty na obrazovce detekují a následně další funkce které nad nalezenýcmi 
komponenty umožňují provest akce podobné těm, které provádí uživatel. Pro kontrolu správnosti provední těchto akcí se používají takzvané tvrzení 
(Assertions), které ověří zdali určité UI prvky mají požadované atributy.

\textit{Finders} umožnují najít uzel nebo uzly ve strom UI struktuře pomocí tagů, vnořených textů, různých popisků a nebo pomocí \textit{Matchers}.


Pomocí \textit{Assertions}

A pomocí \textit{Actions} je možné simulovat uživatelské integrace jako jsou kliknutí nebo jiná gesta. \cite{composeTesting}

\myparagraph{Testování synchoronizace}
\myparagraph{Testování interoperability}

\begin{lstlisting}[caption={Integrace testů Gradle}, label={lst:testsIntegration}, language=Kotlin]
kotlin {
  //...
  sourceSets {
    val desktopTest by getting

    // Adds common test dependencies
    commonTest.dependencies {
      implementation(kotlin("test"))

        @OptIn(org.jetbrains.compose.ExperimentalComposeLibrary::class)
        implementation(compose.uiTest)
    }

    // Adds the desktop test dependency
    desktopTest.dependencies {
        implementation(compose.desktop.currentOs)
    }
  }
}
\end{lstlisting}
\section{Testovací případy}
Testovací případ je sada kroků nebo akcí, které jsou prováděny při testování softwarového produktu s cílem ověřit, zda se chová podle očekávání a splňuje 
požadavky. Každý testovací případ obvykle obsahuje následující prvky:

\begin{itemize}
  \item Popis: Stručný popis toho, co testovací případ testuje a jaké jsou očekávané výsledky.
  \item Předpoklady: Podmínky, které musí být splněny nebo konfigurace, která musí být provedena před spuštěním testu.
  \item Kroky: Konkrétní kroky, které musí být provedeny k provedení testu.
  \item Očekávané výsledky: Popis očekávaných výsledků testu po dokončení kroků.
  \item Aktuální výsledky: Skutečné výsledky testu, které jsou porovnány s očekávanými výsledky k určení úspěšnosti testu.
\end{itemize}

Na základě této struktury bylu sepsány následující testovací případy:


\myparagraph{Testovací případ 1: Zobrazení aktuálních novinek}

\begin{enumerate}
  \item Kroky:
    \begin{enumerate}
      \item Navigace na stránku zobrazující aktuální novinky.
      \item Ověření, že systém zobrazil seznam aktuálních novinek.
      \item Kliknutí na konkrétní novinku.
      \item Ověření, že systém zobrazil detaily vybrané novinky.
    \end{enumerate}
  \item Očekávaný výstup:
    \begin{itemize}
      \item Seznam aktuálních novinek je zobrazen.
      \item Po kliknutí na konkrétní novinku jsou zobrazeny její detaily.
    \end{itemize}
\end{enumerate}

\myparagraph{Testovací případ 2: Zobrazení aktuálních událostí}

\begin{enumerate}
  \item Kroky:
    \begin{enumerate}
      \item Navigace na stránku zobrazující aktuální události.
      \item Ověření, že systém zobrazil seznam aktuálních událostí.
      \item Kliknutí na konkrétní událost.
      \item Ověření, že systém zobrazil detaily vybrané události.
    \end{enumerate}
  \item Očekávaný výstup:
    \begin{itemize}
      \item Seznam aktuálních událostí je zobrazen.
      \item Po kliknutí na konkrétní událost jsou zobrazeny její detaily.
    \end{itemize}
\end{enumerate}

\myparagraph{Testovací případ 3: Filtrování zobrazených událostí podle data}

\begin{enumerate}
  \item Kroky:
    \begin{enumerate}
      \item Navigace na stránku zobrazující události.
      \item Ověření, že systém zobrazil seznam událostí.
      \item Zvolení konkrétního data pro filtrování událostí.
      \item Ověření, že systém zobrazil události pouze pro vybrané datum.
    \end{enumerate}
  \item Očekávaný výstup:
    \begin{itemize}
      \item Seznam událostí je filtrován podle zvoleného data.
      \item Události jsou rozděleny do kategorií podle typu události.
    \end{itemize}
\end{enumerate}

\section{Implementace testů}


\myparagraph{Testy jednotlivých UI komponent}

\begin{lstlisting}[caption={Implementace UI testu}, label={lst:testImplementation}, language=Kotlin]
  class ExampleTest {

  @OptIn(ExperimentalTestApi::class)
  @Test
  fun myTest() = runComposeUiTest {
      // Declares a mock UI to demonstrate API calls
      //
      // Replace with your own declarations to test the code of your project
      setContent {

          var text by remember { mutableStateOf("Hello") }
          Text(
              text = text,
              modifier = Modifier.testTag("text")
          )
          Button(
              onClick = { text = "Compose" },
              modifier = Modifier.testTag("button")
          ) {
              Text("Click me")
          }
      }

      // Tests the declared UI with assertions and actions of the Compose Multiplatform testing API
      onNodeWithTag("text").assertTextEquals("Hello")
      onNodeWithTag("button").performClick()
      onNodeWithTag("text").assertTextEquals("Compose")
  }
}
\end{lstlisting}

\myparagraph{End-to-end testy}


\section{Zhodnocení výsledků testování}

\section{Zhodnocení použitelnosti}

android already in production with hell a lot of features now If you want to share code among these and have single code base, going with flutter is bad idea .. Since its take nativity out. So hence you want both the teams to have a common business logic and networking thing then KMM is the way to go 

\chapter{Závěr}

\section{Evaluace vlastností Compose Multiplatform ve srovnání s cíli práce}
Vetšinu cílů, které byly stanoveny v zadání bylo možné pomocí multiplatformího frameworku Compose Multiplatform splnit a nebylo tak
nutné přistupovat na kompromisy. Veškeré implem

Nicméně při implementacni náročnějších částech aplikace bylo již občas nutné přistoupit k použití nativních řešení a tím pádem tyto dva přístupy zkombinovat.
Ve výsledku z poheledu UI, tak tato kombinace nevedla k zádným ústupkům
Nicméně díký vhodně navrženým principům jako je Expect a actual deklarace (viz paragraf \ref{expectActual}) nebylo skombinování těchto odlišných částí nikterak
implementačně komplikované a ne výsledku ani nepřehledné. 

Fakt že v některých případech bylo nutné přistoupit k nativnímu řešení nemusí být brán jakožto nevýhoda Compose Multiplatform oproti ostatním frameworkům.
Na druhou stranu lze tatu možnost vnimat i jako výhodu, kterou ostatní frameworky neposkytují a dělá takz compose Multiplatform z tohoto pohledu flexibilnější
framework.

prostor o rozříšení ostatních naticvních knihoven o mmmultipatformní API. 

Čehož výsledky by v ideáním případě bylo na daném vývojáří zdali zvolí nativní či multipaltformí cetu vývoje. 

\section{Zkušenosti z implementace na reálné aplikaci}
Preview
Nedostatek knihoven
Špatná nebo téměř žádna dokumentace k knihovnám třetích stran a v případě co se týče Compose Multiplatfrom
\section{Závěr o použitelnosti frameworku}
Jelikož je závěrečné hodnocení této nově nastupující technologie stěžejní částí práce, tak aby bylo toto hodnocení co 
nejobjetivnější, tak bude rozvrženno do několika částí.

Nejprve bude framework porovnán na základě provedné analýzy a to jednak z pohledu architektury, 

Co se pokrytí aktuálně používaných platforem týka, tak Compose Multiplatform pokrývá většinu z akluálně nejžádanějších 
platforem pro vývoj multipaltformních aplikací a dá se tak očekávat, že po uvolnění stabilních verzí pro veškeré 
aktuálně nabízené platformy se jeho obliba ještě zvýší. 

V oblasti výkonu se Compose Multiplatform docela dobře daří a je konkurenceschopný s ostatními multiplatformními frameworky.
V případě větších projektů by však tento rozdíl mohl být výraznější.

Rychlost vývoje je také významným hlediskem. 
Co se rychlosti vývoje týká, tak při tvorbě UI, tak V porovnání s jinými frameworky, jako je například Flutter, má Compose Multiplatform strukturu kódu s méně znaky.


V oblasti optimalizace má však Compose Multiplatform ještě poměrně velké nedostatky a to zejména v plynulosti provozu na 
platformě iOS.


Pokud jde o připravenost IDE, situace je obdobná.  Při implementaci a to před
opriti Flutteru nenebízí tolik možnonstí upravy už jako  například zanoření některých kompent do jiných, ale díky jednoduchosti
zápisu UI jsou tyto akce o něco jednosušší.

A co se výběru IDE týka, tak z otestovaných IDE Android Studio jednoznačně předčilo Fleet. Nicméně tato situace se může, 
taktéž rychle změnit.

V průběhu implementace bylo narazeno na několik problému, které byli nahlášeny a postupně se na nich začína pracovat.

Z pohledu komunity se s ,


Z pohledu dokumentace jsou zde velikoé nedostky, ale díky Jetpack Compose není potřeba a většina postupů jak jednotlivé části 
UI tvořit je dobře dokumentovaná společností Google. 

Z pohledu KMP je tato situace horší
I přesto, že je KMP již ve stabilní verzi, tak dokumentace oproti ostatním technologiím velmi zaostává.



Následně bude porovnán z pohledu implementace  jak z pouheledu tvorby UI, tak z pohledu tvorby aplikační logiky,



Při závěrečném hodnocení frameworku Compose Multiplatform se dá říci, že 
je Compose Multiplatform vhodným nástrojem pro vývoj multiplatformních aplikací, ačkoli existují oblasti, 
ve kterých může být ještě zlepšen.


Co se týka náročnosti implementace aplikac i na ostatních platformách, tak zde byla náročnost
o něco zvýšena kvůli nemožnosti implemtace iOS aplikace již od začátku. jelikož je ke kompilaci potřeba 


% kapitola main pains
% https://blog.jetbrains.com/kotlin/2021/01/results-of-the-first-kotlin-multiplatform-survey/


\section{Shrnutí dosažených výsledků}
Podařilo se navrhnou aplikaci tak aby fungovala na více platformách.  

Součástí návrhu byl také obecně použitelný designový systém, který může být použit k rozšíření nebo tvorbě nových aplikací v navrženém stylu.

Aplikace byla úspěšně přizpůsobena konkrétnímu městu a napojena na jeho infrastrukturu pro získávání dat o událostech, 
aktualitách a parkovacích zónách. Díky implementaci lokální databáze je aplikace použitelná i v offline režimu.

Díky navržené architektuře je možné aplikaci kdykoliv v budoucnu rozšířit o další funkce. 

Poskytuje občanů rychlí přehle o aktálním dění ve městě a zároveň 

Poskytuje moderní UI, které odpovídá moderním standartům společnost Google pro vývoj mobilních aplikací.
vsetne fukci jako je vyuziti tmavého motivu.

Podařilo se naimplementovat multipaltformí aplikaci, která splňuje požadavky zadání a je spusittelná na mobilních 
platformách Android a iOS. 

Zároveň shlukuje co největší množství kódu ve společné části, čím ukazuje možnosti frameworku a 

zarověň ale ukazaje jak framework umožnuje implementaci navních částí, 

Jedinečný design, pokocí čeho ukažu možnosti daklarativního zápisu UI pomocí Compose Multiplatform.

Z pohledu UI splnňuje veškeré stanovené požadavky

S podařilo naimplementovat UI testy, které testují klíčové částí uživatelského rozhraní.

Ukázalo se, že i v současné fázi vývoje je možné pomocí této technologie vytvořit použitelnou aplikaci.

\section{Zhodnocení splnění cílů práce}
\section{Návrhy pro budoucí vývoj a výzkum}
Z pohledu aplikace jsou zde velké možnosti pro budoudcí vývoj 
at už z pohledu rychlosti UI, propojení s dalšími systémy města, implementaci další UI testu a unit testu
otestovani na vize zařízeních

A navhnout tak pro města intuitivní aplikace, která by díky multipaltformím vlastnostem pokryla co nejvetší množství zařízení
a zároven by byla snadněji udržovatelná.

Zároveň umožnuje snadnou imtegraci mapových prvků 

nicméně 


Časem se zajisté ukáží

\bigskip

mohou ukázat další možnosti využití tohoto frameworku na jiných platformách

uz je prubehu psani teto prace vzniklo nekolik novych funkcionalit ktere nebyli otesovany jako napriklad moznost
implementovat viepodely na platforme ios stejne jako je tomu na android zarizenich.

